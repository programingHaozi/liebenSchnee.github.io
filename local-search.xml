<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Runtime简介</title>
    <link href="/2020/04/16/Runtime%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/04/16/Runtime%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Runtime简介"><a href="#Runtime简介" class="headerlink" title="Runtime简介"></a>Runtime简介</h2><p>OC语言会尽可能的将代码（库）编译和链接等操作推迟到运行的时候去处理。这意味着OC不仅需要编译器，更需要一个运行时系统来动态的执行编译的代码。运行时系统就好比OC的操作系统，让OC真正运转起来。</p><p>这篇文档聚焦于OC中的基类<code>NSObject</code>以及OC语言是如何与运行时系统进行交互的，另外会特别解析类的动态创建加载以及转发消息给其他类的过程。同时也会提供在项目运行过程中获取类相关信息的方法。</p><p>阅读这篇文档会让你理解OC运行时的机制并且如何善加利用成为大牛，当然，这并不意味这一定要懂运行时才能开发苹果应用（但是不懂的话肯定是不能装逼了:no_good:）。</p><h1 id="平台及版本"><a href="#平台及版本" class="headerlink" title="平台及版本"></a>平台及版本</h1><p>简单了解一下Runtime的历史版本</p><table><thead><tr><th></th><th>语言版本</th><th>硬件及软件版本</th><th>异同</th></tr></thead><tbody><tr><td>modern（现代版）</td><td>OC2.0</td><td>iPhone，64bit OS X v10.5~</td><td>改变父类属性结构，不需要重新编译其子类</td></tr><tr><td>legacy（遗产版）</td><td>OC1.0</td><td>32bit OS X</td><td>改变父类属性结构，需要重新编译其子类</td></tr></tbody></table><h1 id="runtime的应用"><a href="#runtime的应用" class="headerlink" title="runtime的应用"></a>runtime的应用</h1><p>OC项目主要在三个方面运用到运行时系统：OC代码编写；使用Foundation库中的<code>NSObject</code>基类定义的各类方法；直接调用运行时动态库函数。</p><h2 id="OC代码"><a href="#OC代码" class="headerlink" title="OC代码"></a>OC代码</h2><p>大部分时候，运行时扮演着幕后角色，在你编写，编译OC代码时偷偷摸摸在后面搞事情。编写包含OC的类和方法时，编译器会生成对应的数据结构和函数调用，数据结构会从类，分类以及代理里获取类对象，代理对象，函数，实例变量等等信息。获取信息的方法就是通过运行时的蓝波湾机制–消息机制。</p><h2 id="NSObject-方法"><a href="#NSObject-方法" class="headerlink" title="NSObject 方法"></a>NSObject 方法</h2><p>Cocoa中大部分对象都是<code>NSObject</code>的子类，它们都继承了<code>NSObject</code>定义的方法（NSProxy是个例外）。一般来说，<code>NSObject</code>定义的方法决定了它的实例和子类的行为，但在部分情况下，<code>NSObject</code>仅仅提供某些行为的模板，而不是提供具体的代码实现。</p><p>例如，<code>NSObject</code>定义了一个名为<code>description</code>的实例方法，用来返回一个描述类包含内容的字符串。这个方法主要用来调试使用，GDB的调试命令<code>print-object</code>打印的即是从<code>description</code>这个方法返回的字符串。<code>NSObject</code>在实现<code>description</code>这个方法时并不知道当前类的内容，所以单纯的返回了当前类的名称和地址信息。<code>NSObject</code>的子类可以重写这个方法以返回更多信息，例如<code>NSArray</code> 的<code>description</code>方法返回的是它所包含的元素的信息。</p><p>部分<code>NSObject</code>的方法更是直接从运行时系统中获取自身相关的一些信息。例如</p><p><code>class</code>方法用来获取对象的类；</p><p><code>isKindOfClass:</code>和<code>isMemberOfClass:</code>用来判断对象的继承树；</p><p><code>respondsToSelector:</code>用来判断对象能否响应某些特定的消息；</p><p><code>conformsToProtocol:</code>用来判断对象是否实现了某个协议中的方法；</p><p><code>methodForSelector:</code>提供了某个方法的实现地址；</p><p>类似于上述的这些方法，给了对象剖析自身信息的一种能力。</p><h2 id="Runtime-函数"><a href="#Runtime-函数" class="headerlink" title="Runtime 函数"></a>Runtime 函数</h2><p>运行时系统是一个共享动态库，位于系统的<code>/usr/lib/objc</code>，在它的头文件中提供了一系列的函数和数据结构作为公开接口。这里面的许多函数允许你用简单的C语言复刻编译器在你编写OC代码时所做的事情。其他的一些函数则促成了<code>NSObject</code>类中函数功能性输出的基础（我也不知道这句话翻译的是什么鬼。。）。这些函数可以让我们开发与运行时交互的更多接口以及增加开发环境的工具。虽然编写OC代码并不太需要运行时函数，但是在某些情况下，运行时对于项目开发帮助很大。<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime" target="_blank" rel="noopener">运行时官方文档</a></p><h1 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h1><p>这一段将解析消息表达式是如何转化为<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="noopener">objc_msgSend</a>函数调用的，以及你如何通过名称找到方法。然后我们会讲解怎么利用<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="noopener">objc_msgSend</a>函数，怎么避免动态绑定（如果需要的话）。</p><h2 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h2><p>在OC中，消息在运行时之前是不会和函数实现绑定在一起的。编译器会将消息转化为一个表达式：</p><pre><code class="objc">[receiver message]</code></pre><p>让他去调用消息函数–<code>objc_msgSend</code>，消息函数会将上述消息结构体中的receiver和message中包含的方法名（即我们所熟悉的selector）作为自己的2个主要参数</p><pre><code>objc_msgSend(receiver, selector)</code></pre><p>任何传给message消息的参数都会传递给<code>objc_msgSend</code>函数</p><pre><code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code></pre><p><code>objc_msgSend</code>函数实现了动态绑定的过程：</p><ul><li>同一个方法可能被不同的类实现，首先根据receiver的类找到selector对应的方法实现MI（method implementation）。</li><li>将reveicer对象（指针或数据）以及传递给<code>objc_msgSend</code>的参数全部传递给找到的方法实现MI并调用。</li><li>最后，将MI的返回值作为自己的返回值。</li></ul><blockquote><p>编译器会自动将方法调用转化为消息函数<code>objc_msgSend</code>，不要自己在代码里面直接调用。</p></blockquote><p>消息机制的关键在于编译器为每个类和对象构建的数据结构。每个类的数据结构包含2个基本要素：</p><ul><li>指向父类的指针</li><li>类的调度表，调度表能够将方法名selector与对应类定义的方法实现地址关联起来，例如<code>setOrigin::</code>这个方法的方法名会和<code>setOrigin::</code>的方法实现（method implementation）地址关联，<code>display</code>方法名会和<code>display</code>方法实现地址关联等等。</li></ul><p>当一个新对象完成创建，分配完内存空间并且初始化实例变量之后，这个对象实例变量的第一个值–isa指针，指向的则是对象的类，通过isa指针，对象可以获取自己的类，通过自己的类可以获取自己的父类等信息。</p><blockquote><p>严格来说，isa指针并不是OC语言的一部分，但却是OC对象与运行时交互的必要属性。无论在哪里定义，与运行时交互的对象必须类似于 <code>struct objc_object</code>（定义在objc/objc.h，含有isa指针属性）。然后我们并没有必要自己去创建一个根对象，继承自NSObject或NSProxy类的对象自动拥有isa指针属性。</p></blockquote><p>类和对象的数据结构如下图</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeIntro-1.png" srcset="/img/loading.gif" alt=""></p><p>当一个消息发送给一个对象时，消息函数<code>objc_msgSend</code>会根据对象的isa指针找到对象的类，消息函数会在类的调度表中寻找消息的方法名。如果找不到的话，<code>objc_msgSend</code>会根据<code>superclass</code>指针向上找到父类，并在父类的调度表里寻找消息的方法名，若一直失败，则会循环往上查询一直到基类NSObject。一旦定位到了方法名，消息函数<code>objc_msgSend</code>会把对象数据结构及参数传给该方法并对该方法进行调用。</p><p>上述过程即是方法实现在运行时中被调用的过程，从面向对象编程的思想来看，这就是方法与消息动态绑定的方式。</p><p>为了加速消息机制的过程，运行时会把调用过的方法名和方法实现地址缓存起来。每个类都是独自的缓存，不仅可以缓存自己定义的方法，也可以缓存继承的方法。在消息函数<code>objc_msgSend</code>查找调度表之前，会先检查消息对象的缓存（基于消息可能多次调用的想法），如果在缓存中找到了方法，那么消息机制仅仅比直接的方法调用慢了一点点而已。只要程序运行的时间够长来不断的积累“缓存方法”，几乎所有消息都能在缓存中找到方法。缓存会不断的增长对程序运行过程的消息提供越来越快，越来越便利的调用方式。</p><h2 id="使用隐藏参数"><a href="#使用隐藏参数" class="headerlink" title="使用隐藏参数"></a>使用隐藏参数</h2><p>当消息函数<code>objc_msgSend</code>找到方法的实现时，会对方法实现进行调用并传递所有参数。同时，它也会对方法实现传递2个隐藏参数：</p><ul><li>消息对象</li><li>方法选择器selector</li></ul><p>消息表达式中的这两部分参数会将自身的信息传递给每个他们调用的方法。之所以说他们是隐藏参数是因为在源码中定义方法时并不会申明消息对象和方法名。他们是在源码被编译时插入方法实现中的。</p><p>尽管这两个参数没有被明确的声明，但是源码依然可以获取到他们（就像获取消息接收对象的实例变量一样），方法将接收到到的对象为<code>self</code>，将它自己的selector方法选择器称为<code>_cmd</code>。在下面这个示例中，<code>_cmd</code>指的是<code>strange</code>方法的selector方法选择器，<code>self</code>指的是接收到<code>strange</code>消息的对象。</p><pre><code class="objective-c">- strange{    id  target = getTheReceiver();    SEL method = getTheMethod();    if ( target == self || method == _cmd )        return nil;    return [target performSelector:method];}</code></pre><p><code>self</code>在这两个参数中属于更重要的一个，实际上，<code>self</code>是方法定义能够使用接收对象实例变量的一种方式。</p><h2 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h2><p>唯一能够避免方法动态绑定的方式是获取到方法的地址，然后直接当做函数进行调用。在某些不常见的场景下，比如需要对某个特定方法进行非常多次连续的调用，如果你想避免消息机制每次动态绑定的开销，你可以使用这个方式。</p><p>你可以通过<code>NSObject</code>中定义的方法<code>methodForSelector:</code>来获取一个方法的函数实现地址，然后通过这个地址直接调用函数。<code>methodForSelector:</code>这个方法返回的地址需要转换为适当的函数类型，返回值和参数类型都需要包含在转换的函数类型中。</p><p>下面的例子展示了<code>setFilled:</code>方法如何通过函数指针地址调用：</p><pre><code class="objective-c">void (*setter)(id, SEL, BOOL);int i;setter = (void (*)(id, SEL, BOOL))[target    methodForSelector:@selector(setFilled:)];for ( i = 0 ; i &lt; 1000 ; i++ )    setter(targetList[i], @selector(setFilled:), YES);</code></pre><p>传递给函数实现的头两个参数分别是接收对象<code>self</code>和方法的selector方法选择器<code>_cmd</code>。这两个参数在方法定义中隐藏，但是在方法作为函数被调用时必须显式的声明。</p><p>使用<code>methodForSelector:</code>这个方法来避免消息机制的动态绑定节省了许多动态绑定的时间，但是这些只在特定情况，比如上述例子中，for循环里重复多次消息发送时才显得有用处。</p><p>注意到<code>methodForSelector:</code>是由Cocoa运行时提供的方法，并不是Objective-C的特性哦。</p><h1 id="动态方法决议"><a href="#动态方法决议" class="headerlink" title="动态方法决议"></a>动态方法决议</h1><p>这一段将告诉你如何动态的添加一个方法的实现。</p><h2 id="动态方法决议-1"><a href="#动态方法决议-1" class="headerlink" title="动态方法决议"></a>动态方法决议</h2><p>在某些时候，你可能想要自己动态的添加一个方法的实现。举个栗子，OC的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_blank" rel="noopener">属性声明</a>特性中包含了<code>@dynamic</code>关键字</p><pre><code class="objective-c">@dynamic propertyName;</code></pre><p>这个关键字告诉编译器，这个属性关联的方法将会被动态提供。</p><p>你可以通过实现 <code>resolveInstanceMethod:</code>和 <code>resolveClassMethod:</code>方法分别为给定的实例方法和类方法提供方法实现。</p><p>OC中的方法其实等同于C的函数，只是至少包含两个参数——<code>self</code>和<code>_cmd</code>。你可以通过 <code>class_addMethod</code>函数给类添加一个函数作为它的方法。所以，给出以下函数：</p><pre><code class="objective-c">void dynamicMethodIMP(id self, SEL _cmd) {    // implementation ....}</code></pre><p>你可以通过<code>resolveInstanceMethod:</code>这个方法，动态的将上面的函数添加给一个类作为方法（方法名为<code>resolveThisMethodDynamically</code>），如下：</p><pre><code class="objective-c">@implementation MyClass+ (BOOL)resolveInstanceMethod:(SEL)aSEL{    if (aSEL == @selector(resolveThisMethodDynamically)) {          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);          return YES;    }    return [super resolveInstanceMethod:aSEL];}@end</code></pre><p>消息转发（下一段会讲到）和方法动态决议在很大程度上是在正交的。一个类在方法转发介入之前可以对方法进行方法决议，如果 <code>respondsToSelector:</code>或者 <code>instancesRespondToSelector:</code>成功调用返回YES，方法动态决议就有机会先给方法添加动态实现。如果你实现了 <code>resolveInstanceMethod:</code>了但是需要某些特定的方法通过消息转发机制进行转发，你可以在 <code>resolveInstanceMethod:</code>中对这些方法返回NO。</p><h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><p>OC的程序可以在运行时加载链接新的类和分类等，这些新的类和分类会被合并到程序中就像最开始被加载的类和分类一样。</p><p>动态加载可以用来做很多事情，例如系统设置app中的许多模块都是动态加载的。</p><p>在Cocoa的环境中，动态加载通常用来自定义应用，另外可以用来编写各种模块让你的程序在运行时进行加载——就像Xib加载自定义调色板或是OSX系统偏好设置加载自定义偏好模块等。可加载的模块可以扩展你的应用的能力，它们可以以你允许的方式提供帮助，但是你自己是无法预料和定义这个过程的。你提供框架，其他人提供代码。</p><p>尽管在Mach-O文件中已经有运行时的函数（定义在<code>objc/objc-load.h</code>中的<code>objc_loadModules</code>）用来对OC的模块进行动态加载，Cocoa中的<code>NSBundle</code>类中提供了一系列重要且方便的接口——面向对象且整合了相关服务的接口，用来进行动态加载。你可以在Foundation Framework中查看<code>NSBundle</code>类的相关信息及使用，也可以在 <a href="https://github.com/aidansteele/osx-abi-macho-file-format-reference" target="_blank" rel="noopener"><em>OS X ABI Mach-O File Format Reference</em></a>中查看Mach-O文件中的信息。</p><h1 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h1><p>给一个对象发送一个它并未实现的消息时会造成错误，然而，在抛出错误之前，运行时系统会给接收消息的对象第二次机会去处理这个消息。</p><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>如果你向一个对象发送一个未实现的消息A，在抛出错误之前，运行时会向接收消息的对象发送一个 <code>forwardInvocation:</code> 消息，这个消息只有一个 <code>NSInvocation</code> 对象的参数，这个参数包括了原消息A和原消息A所带有的参数。</p><p>你可以实现 <code>forwardInvocation:</code> 方法给消息A一个默认的实现，或者用其他方式避免这种调用错误。通过 <code>forwardInvocation:</code>的字面意思（转发调用）我们可以知道，这个函数通常用来转发消息给其他对象。</p><p>为了了解消息转发的适用范围和意义，想象下面这样一个场景：假设，首先，你设计一个对象A能够响应一个名为 <code>negotiate</code>的方法，这时你希望这个方法的响应包含了另外一个对象B的响应。通过你在对象A中实现 <code>negotiate</code>方法的地方，将 <code>negotiate</code>消息转递给另外一个对象B即可完成。</p><p>更进一步，假设你希望对象A对于 <code>negotiate</code> 这个方法的响应和另外一个对象B对于 <code>negotiate</code> 这个方法的响应完全一致的话，其中一种实现方式是让对象A继承与对象B，然而当对象A和对象B处于不同的继承树之间时，这个方法就不那么好用了。</p><p>当然，即是你的对象A无法继承对象B的 <code>negotiate</code>方法，你仍然可以通过实现你自己版本的<code>negotiate</code>方法，在方法实现中，将<code>negotiate</code>消息传递给对象B的实例以此来“借用”对象B对于<code>negotiate</code>方法的响应。</p><pre><code class="objective-c">- (id)negotiate{    if ( [someOtherObjectB respondsTo:@selector(negotiate)] )        return [someOtherObjectB negotiate];    return self;}</code></pre><p>这种方式的消息转发看起来有点麻烦，特别是当你需要通过你的对象转发一系列消息给其他对象的时候。你需要实现一个方法来覆盖你想要从其他对象那“借用”的每个方法。此外，在你编写代码时，如果你不知道所有你需要转发的消息时，也不可能处理这些情况。这些需要转发的消息集可能依赖于运行时，并且可能随着未来新的方法和类的加入而改变。</p><p>给我们第二次机会的 <code>forwardInvocation:</code> 方法提供了一个不那么特别的方式来解决这个问题，并且与上面的方式相比更加动态。这个方法的机制是这样的：当一个对象由于没有对应的方法与接收到的消息匹配而无法响应这个消息时，运行时系统通过发送 <code>forwardInvocation:</code>消息给这个对象来通知它。每个继承自NSObject的对象都继承了 <code>forwardInvocation:</code>这个方法。然而NSObject对于这个方法的默认实现是直接调用 <code>doesNotRecognizeSelector:</code>抛出异常。通过重写<code>forwardInvocation:</code>这个方法你可以利用它将接收到的消息转发给其他对象。</p><p>转发消息，<code>forwardInvocation:</code>需要做一下两步：</p><ul><li>确定这个消息应该转发给谁</li><li>将消息的原始参数带上，将消息转发给对应的对象</li></ul><p>消息时通过 <code>invokeWithTarget:</code> 这个方法转发出去的</p><pre><code class="objective-c">- (void)forwardInvocation:(NSInvocation *)anInvocation{    if ([someOtherObject respondsToSelector:            [anInvocation selector]])        [anInvocation invokeWithTarget:someOtherObject];    else        [super forwardInvocation:anInvocation];}</code></pre><p>被转发消息的返回值将会被返回给消息的原始发送者，包括id，结构体，单精度，双精度浮点数等等。</p><p> <code>forwardInvocation:</code> 方法可以被看作是不识别消息的配送中心，它可以将这些不被识别的消息转发给不同的接受者。或者，你可以将它看做是转运站，它可以将所有消息最终传递到同一个目的地。它可以将一个消息转化为另一个消息，或者干脆“吃掉”一些消息，让它们没有响应也不会报错。 <code>forwardInvocation:</code> 也可以将好几个消息合并起来只返回一个响应。 <code>forwardInvocation:</code> 的作用完全取决于它自身的实现，但是，它在转发链中提供的链接不同对象的机会，使多样灵活的程序设计成为可能。</p><blockquote><p><code>forwardInvocation:</code> 只有在对象（消息接受者）没有实现某个消息对应的方法时，才会接手对消息的转发。举个栗子，如果你想要对象A把 <code>negotiate</code> 转发给其他对象，那么对象A就不能实现自己的 <code>negotiate</code> 方法，否则，<code>forwardInvocation:</code> 永远不会对 <code>negotiate</code> 进行转发。</p></blockquote><p>如果你想要了解更多消息转发以及调用的信息，可以查阅Foundation framework文档中的 <code>NSInvocation</code> 类。</p><h2 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h2><p>消息转发机制有点继承的意味，它可以用来给OC添加一些多继承的效果。如下图所示，一个对象通过消息转发来响应一个消息，有点像是“借用”或者是“继承”了实现了这个消息的另一个类。</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeIntro-2.png" srcset="/img/loading.gif" alt=""></p><p>如上图示，一个<code>Warrior</code>（战士）类的对象转发了 <code>negotiate</code> （协商）消息给了一个<code>Diplomat</code>（外交官）类的对象，那么这个“战士”对象将会像“外交官”对象一样响应“协商”方法。（实际上“协商”消息一直是“外交官”对象在处理）。</p><p>一个对象通过转发消息因而“继承”了两个继承树分支——它自己的继承树分支以及响应转发消息的对象的继承树分支的方法。在上述的例子中，看起来好像是<code>Warrior</code>（战士）类对象同时继承了<code>Warrior</code>（战士）类和<code>Diplomat</code>（外交官）类。</p><p>消息转发提供了你通常希望从多继承获得的大部分特性，然而这两者有个很重要的区别：多继承会融合很多不同的特性在同一个对象上，它倾向于更大，更多面的对象；而消息转发是将不同的职责分配给不同的对象，它将问题分解为更小的对象去处理，对于消息发送者，消息转发对于不同对象的链接联合是透明可见的。</p><h2 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h2><p>消息转发不但模仿多继承，它还可以让更轻量级的对象来表示或“顶替”更复杂的对象。这些轻量级的对象会代替其他对象，并且将收到的消息转发给它们。</p><p>我们在 <em><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="noopener">The Objective-C Programming Language</a></em> 中“Remote Messaging”里面讨论的“Proxy（代理）”正是一个代理对象，一个proxy负责管理将消息发送给远程接受者过程中的各种细节，确保在连接过程中参数的复制和接收等等。但是也仅此而已，它并不会复制远程对象的功能性，只是简单的提供一个本地地址，让它可以在其他应用中接收消息。</p><p>也有其他类型的代理对象，例如，当你有一个需要处理非常多数据——创建复杂图像或者读取磁盘数据等的对象，设置此对象可能非常耗时，这时你打算使用懒加载的方式——当需要使用到它或者系统资源空闲的时候来做。与此同时，你需要一个默认的代理对象来代替这个复杂的对象，以便让程序中其他的对象能够正常工作。</p><p>在这种情况下，你一开始可以只创建一个非常简单的代理对象，这个对象可以做一些简单的操作例如返回对于数据的查询，但主要还是帮复杂对象“占个位”，当时机来临，将消息转发给复杂对象。当代理对象的 <code>forwardInvocation:</code> 方法首次接收到需要传递给其他对象的消息时，代理对象会确保消息接收对象存在或者在其不存在时创建一个。所有需要传递给复杂对象的消息都经由代理对象发出，所以，在程序的其他部分看来，代理对象和复杂对象其实并没有区别。</p><h2 id="转发与继承"><a href="#转发与继承" class="headerlink" title="转发与继承"></a>转发与继承</h2><p>虽然上面说了很多转发模仿继承之类的，但是<code>NSObject</code>类从来不会将两者混为一谈，像 <code>respondsToSelector:</code> 和<code>isKindOfClass:</code>方法只在继承树中做判断，从来不会在转发链中去判断。例如，当上述<code>Warrior</code>（战士）类调用 <code>respondsToSelector:</code> 方法来判断是否响应 <code>negotiate</code> 消息时</p><pre><code class="objective-c">if ( [aWarrior respondsToSelector:@selector(negotiate)] )    ...</code></pre><p>返回值是<code>NO</code>，即是它在某种意义上，通过将消息转发给<code>Diplomat</code>（外交官）类，可以正确的响应 <code>negotiate</code> 消息。</p><p>在很多情况下，<code>NO</code>是正确的答案，但事实可能并非如此。如果你利用消息转发创建一个代理对象或者扩展一个类的能力，转发机制应该和继承一样清晰可见。如果你希望你的对象通过将消息转发给其他对象，就像真正继承了这些对象的行为，那么你需要重写<code>respondsToSelector:</code>和<code>isKindOfClass:</code>等这些方法，将消息转发机制考虑在内</p><pre><code class="objective-c">- (BOOL)respondsToSelector:(SEL)aSelector{    if ( [super respondsToSelector:aSelector] )        return YES;    else {        /* Here, test whether the aSelector message can     *         * be forwarded to another object and whether that  *         * object can respond to it. Return YES if it can.  */    }    return NO;}</code></pre><p>除了 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>外， <code>instancesRespondToSelector:</code> 方法也应该考虑转发机制，如果使用到协议，那么 <code>conformsToProtocol:</code> 方法同样要考虑转发机制。同样的，如果一个对象可以转发它收到的任何消息，它应该实现 <code>methodSignatureForSelector:</code>这个方法，这个方法可以返回最终响应转发消息的方法的详细信息，即<code>NSMethodSignature</code>方法签名，举个栗子，如果一个对象可以转发消息给他的代理对象，那么你应该实现 <code>methodSignatureForSelector:</code>，如下：</p><pre><code class="objective-c">- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector{    NSMethodSignature* signature = [super methodSignatureForSelector:selector];    if (!signature) {       signature = [surrogate methodSignatureForSelector:selector];    }    return signature;}</code></pre><p>你可以考虑将转发消息的一些判断或算法抽离出来放在私有代码里，然后让上述<code>respondsToSelector:</code>，<code>isKindOfClass:</code>，<code>instancesRespondToSelector:</code> ，包括<code>forwardInvocation:</code>等方法去调用它。</p><blockquote><p>消息转发是一种高级技巧，只适用于在走投无路的时候使用，它并不是继承的代替方案。如果你一定要使用消息转发，确保你充分了解，转发消息的类和消息接收类的行为。</p></blockquote><p>这一段提到的各种方法收录在 Foundation framework文档中的<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject" target="_blank" rel="noopener">NSObject</a> 类里。 <code>invokeWithTarget:</code>方法的相关内容在Foundation framework文档中<a href="https://developer.apple.com/documentation/foundation/nsinvocation" target="_blank" rel="noopener">NSInvocation</a>里。</p><h1 id="类型编码"><a href="#类型编码" class="headerlink" title="类型编码"></a>类型编码</h1><p>为了辅助运行时系统，编译器会将每个方法的参数和返回值编码成字符串形式，并把这个字符串和方法选择器selector关联起来。这种编码形式在其他场景下也适用，可以使用公用的编译器指令 <code>@encode()</code> 来应用。当给定一种类型， <code>@encode()</code> 指令会返回这种类型的字符串编码。这种类型可以是<code>int</code>，指针，结构体，<code>union</code>或者是任何类的名称。事实上，编码后的字符串也可以作为C语言 <code>sizeof()</code> 操作的参数。</p><pre><code class="objective-c">char *buf1 = @encode(int **);char *buf2 = @encode(struct key);char *buf3 = @encode(Rectangle);</code></pre><p>下表中列出了各种类型编码。需要注意的是，当对一个对象进行<code>archive</code>或<code>distribution</code>操作编码时，下列类型编码会和你自己的代码重复。然而在你编写编码器时，下列的一些类型编码你无法使用，还有一些编码在你编写不是由<code>@encode()</code>方法生成的编码器时可以使用。（具体参照Foundation Framework中<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSCoder/Description.html#//apple_ref/occ/cl/NSCoder" target="_blank" rel="noopener">NSCoder</a>类，获取更多关于<code>archive</code>或<code>distribution</code>相关编码信息）</p><table><thead><tr><th align="left">Code</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><code>c</code></td><td align="left">A <code>char</code></td></tr><tr><td align="left"><code>i</code></td><td align="left">An <code>int</code></td></tr><tr><td align="left"><code>s</code></td><td align="left">A <code>short</code></td></tr><tr><td align="left"><code>l</code></td><td align="left">A <code>long``l</code> is treated as a 32-bit quantity on 64-bit programs.</td></tr><tr><td align="left"><code>q</code></td><td align="left">A <code>long long</code></td></tr><tr><td align="left"><code>C</code></td><td align="left">An <code>unsigned char</code></td></tr><tr><td align="left"><code>I</code></td><td align="left">An <code>unsigned int</code></td></tr><tr><td align="left"><code>S</code></td><td align="left">An <code>unsigned short</code></td></tr><tr><td align="left"><code>L</code></td><td align="left">An <code>unsigned long</code></td></tr><tr><td align="left"><code>Q</code></td><td align="left">An <code>unsigned long long</code></td></tr><tr><td align="left"><code>f</code></td><td align="left">A <code>float</code></td></tr><tr><td align="left"><code>d</code></td><td align="left">A <code>double</code></td></tr><tr><td align="left"><code>B</code></td><td align="left">A C++ <code>bool</code> or a C99 <code>_Bool</code></td></tr><tr><td align="left"><code>v</code></td><td align="left">A <code>void</code></td></tr><tr><td align="left"><code>*</code></td><td align="left">A character string (<code>char *</code>)</td></tr><tr><td align="left"><code>@</code></td><td align="left">An object (whether statically typed or typed <code>id</code>)</td></tr><tr><td align="left"><code>#</code></td><td align="left">A class object (<code>Class</code>)</td></tr><tr><td align="left"><code>:</code></td><td align="left">A method selector (<code>SEL</code>)</td></tr><tr><td align="left">[<em>array type</em>]</td><td align="left">An array</td></tr><tr><td align="left">{<em>name=type…</em>}</td><td align="left">A structure</td></tr><tr><td align="left">(<em>name</em>=<em>type…</em>)</td><td align="left">A union</td></tr><tr><td align="left"><code>b</code>num</td><td align="left">A bit field of <em>num</em> bits</td></tr><tr><td align="left"><code>^</code>type</td><td align="left">A pointer to <em>type</em></td></tr><tr><td align="left"><code>?</code></td><td align="left">An unknown type (among other things, this code is used for function pointers)</td></tr></tbody></table><blockquote><p>注意：Objective-C 并不支持 <code>long double</code> 类型，<code>@encode(long double)</code>方法返回值为<code>d</code>，和<code>double</code>编码相同</p></blockquote><p>数组的类型编码是由中括号包起来的，数组的元素数量紧跟着左括号后面，例如，一个包含12个指向浮点数的指针数组会被编码成</p><pre><code class="c">[12^f]</code></pre><p>结构体的编码会被大括号包裹，而联合的编码则被小括号包裹，结构体的标签会列在括号里第一位，紧着这后面是一个等于号，然后就是结构体内部的各项属性的编码，例如</p><pre><code class="c">typedef struct example {    id   anObject;    char *aString;    int  anInt;} Example;</code></pre><p>这个结构体会被编码为</p><pre><code class="c">{example=@*i}</code></pre><p>无论是将结构体的名称（Example）或是结构体的标签（example）传递给 <code>@encode()</code>方法编码后都是上述结果。结构体指针的编码同样会带着结构体编码的内容：</p><pre><code class="c">^{example=@*i}</code></pre><p>然而，对于结构体指针的指针编码，则会移除结构体的编码结构：</p><pre><code class="c">^^{example}</code></pre><p>对象编码类似于结构体编码，例如，将 <code>NSObject</code> 类名传给 <code>@encode()</code>进行编码，结果是</p><pre><code class="c">{NSObject=#}</code></pre><p> <code>NSObject</code> 对象只申明了一个实例变量——<code>isa</code>，代表类的类型。</p><p>注意到到下表中额外的类型编码，尽管不是通过 <code>@encode()</code> 方法返回的，但是运行时系统会使用下列编码来标识在协议中申明的方法的类型。</p><table><thead><tr><th align="left">Code</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><code>r</code></td><td align="left"><code>const</code></td></tr><tr><td align="left"><code>n</code></td><td align="left"><code>in</code></td></tr><tr><td align="left"><code>N</code></td><td align="left"><code>inout</code></td></tr><tr><td align="left"><code>o</code></td><td align="left"><code>out</code></td></tr><tr><td align="left"><code>O</code></td><td align="left"><code>bycopy</code></td></tr><tr><td align="left"><code>R</code></td><td align="left"><code>byref</code></td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>oneway</code></td></tr></tbody></table><h1 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h1><p>当编译器处理属性声明（在 *<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="noopener">The Objective-C Programming Language</a>*中查看 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_blank" rel="noopener">Declared Properties</a>）时，编译器会生成与声明属性所属类或分类或代理协议等相关的描述性元数据。你可以通过支持从类或者协议中查询属性名称的方法来获取这些元信息，获取属性<code>@encode</code>编码方式的类型字符，还可以以C字符串数组的形式获取属性的属性列表。声明属性的列表对每个类和协议都适用。</p><h2 id="属性类型及函数"><a href="#属性类型及函数" class="headerlink" title="属性类型及函数"></a>属性类型及函数</h2><p> <code>Property</code> 属性结构体描述了属性描述符的不透明句柄。</p><pre><code class="objective-c">typedef struct objc_property *Property;</code></pre><p>你可以使用 <code>class_copyPropertyList</code> 和 <code>protocol_copyPropertyList</code> 来分别获取类，分类，协议等相关的属性列表信息</p><pre><code class="objective-c">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)</code></pre><p>举个栗子，如下定义类：</p><pre><code class="objective-c">@interface Lender : NSObject {    float alone;}@property float alone;@end</code></pre><p>你可以这样获取它的属性列表：</p><pre><code class="objective-c">id LenderClass = objc_getClass(&quot;Lender&quot;);unsigned int outCount;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</code></pre><p>你可以使用 <code>property_getName</code> 方法来获取属性的名称：</p><pre><code class="objective-c">const char *property_getName(objc_property_t property)</code></pre><p>你可以通过 <code>class_getProperty</code> 和 <code>protocol_getProperty</code> 方法，通过给定的名称分别从类和协议中获取指定的属性：</p><pre><code class="objective-c">objc_property_t class_getProperty(Class cls, const char *name)objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</code></pre><p>你可以通过 <code>property_getAttributes</code> 方法来获取属性的名称和 <code>@encode</code> 类型编码字符。查看 <a href="#类型编码">类型编码</a>获取更多关于类型编码字符的信息，查看<a href="#属性类型字符">属性类型字符</a> 和 <a href="#属性内容描述示例">属性内容描述示例</a>获取更多关于属性编码字符的信息。</p><pre><code class="objective-c">const char *property_getAttributes(objc_property_t property)</code></pre><p>将上述方法结合起来，我们可以打印和类相关的所有属性信息：</p><pre><code class="objective-c">id LenderClass = objc_getClass(&quot;Lender&quot;);unsigned int outCount, i;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);for (i = 0; i &lt; outCount; i++) {    objc_property_t property = properties[i];    fprintf(stdout, &quot;%s %s\n&quot;, property_getName(property), property_getAttributes(property));}</code></pre><h2 id="属性类型字符"><a href="#属性类型字符" class="headerlink" title="属性类型字符"></a>属性类型字符</h2><p>你可以通过 <code>property_getAttributes</code> 方法来获取属性的名称和 <code>@encode</code> 类型编码字符和属性的其他内容。</p><p>属性的类型编码以T开头，后面紧跟属性的 <code>@encode</code> 类型编码字符和一个逗号，中间部分是属性的修饰符类型的编码字符如下表，以逗号分隔，最后部分是以V开头，后面紧跟属性名称。</p><table><thead><tr><th align="left">Code</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><code>R</code></td><td align="left">The property is read-only (<code>readonly</code>).</td></tr><tr><td align="left"><code>C</code></td><td align="left">The property is a copy of the value last assigned (<code>copy</code>).</td></tr><tr><td align="left"><code>&amp;</code></td><td align="left">The property is a reference to the value last assigned (<code>retain</code>).</td></tr><tr><td align="left"><code>N</code></td><td align="left">The property is non-atomic (<code>nonatomic</code>).</td></tr><tr><td align="left"><code>G&lt;name&gt;</code></td><td align="left">The property defines a custom getter selector name. The name follows the <code>G</code> (for example, <code>GcustomGetter,</code>).</td></tr><tr><td align="left"><code>S&lt;name&gt;</code></td><td align="left">The property defines a custom setter selector name. The name follows the <code>S</code> (for example, <code>ScustomSetter:,</code>).</td></tr><tr><td align="left"><code>D</code></td><td align="left">The property is dynamic (<code>@dynamic</code>).</td></tr><tr><td align="left"><code>W</code></td><td align="left">The property is a weak reference (<code>__weak</code>).</td></tr><tr><td align="left"><code>P</code></td><td align="left">The property is eligible for garbage collection.</td></tr><tr><td align="left"><code>t&lt;encoding&gt;</code></td><td align="left">Specifies the type using old-style encoding.</td></tr></tbody></table><p>示例请看<a href="##属性内容描述示例">属性内容描述示例</a>。</p><h2 id="属性内容描述示例"><a href="#属性内容描述示例" class="headerlink" title="属性内容描述示例"></a>属性内容描述示例</h2><p>给出以下定义：</p><pre><code class="objective-c">enum FooManChu { FOO, MAN, CHU };struct YorkshireTeaStruct { int pot; char lady; };typedef struct YorkshireTeaStruct YorkshireTeaStructType;union MoneyUnion { float alone; double down; };</code></pre><p>下表中展示了示例声明属性以及 <code>property_getAttributes</code>:方法的返回值：</p><table><thead><tr><th align="left">Property declaration</th><th align="left">Property description</th></tr></thead><tbody><tr><td align="left"><code>@property char charDefault;</code></td><td align="left"><code>Tc,VcharDefault</code></td></tr><tr><td align="left"><code>@property double doubleDefault;</code></td><td align="left"><code>Td,VdoubleDefault</code></td></tr><tr><td align="left"><code>@property enum FooManChu enumDefault;</code></td><td align="left"><code>Ti,VenumDefault</code></td></tr><tr><td align="left"><code>@property float floatDefault;</code></td><td align="left"><code>Tf,VfloatDefault</code></td></tr><tr><td align="left"><code>@property int intDefault;</code></td><td align="left"><code>Ti,VintDefault</code></td></tr><tr><td align="left"><code>@property long longDefault;</code></td><td align="left"><code>Tl,VlongDefault</code></td></tr><tr><td align="left"><code>@property short shortDefault;</code></td><td align="left"><code>Ts,VshortDefault</code></td></tr><tr><td align="left"><code>@property signed signedDefault;</code></td><td align="left"><code>Ti,VsignedDefault</code></td></tr><tr><td align="left"><code>@property struct YorkshireTeaStruct structDefault;</code></td><td align="left"><code>T{YorkshireTeaStruct=&quot;pot&quot;i&quot;lady&quot;c},VstructDefault</code></td></tr><tr><td align="left"><code>@property YorkshireTeaStructType typedefDefault;</code></td><td align="left"><code>T{YorkshireTeaStruct=&quot;pot&quot;i&quot;lady&quot;c},VtypedefDefault</code></td></tr><tr><td align="left"><code>@property union MoneyUnion unionDefault;</code></td><td align="left"><code>T(MoneyUnion=&quot;alone&quot;f&quot;down&quot;d),VunionDefault</code></td></tr><tr><td align="left"><code>@property unsigned unsignedDefault;</code></td><td align="left"><code>TI,VunsignedDefault</code></td></tr><tr><td align="left"><code>@property int (*functionPointerDefault)(char *);</code></td><td align="left"><code>T^?,VfunctionPointerDefault</code></td></tr><tr><td align="left"><code>@property id idDefault;</code>Note: the compiler warns: <code>&quot;no &#39;assign&#39;, &#39;retain&#39;, or &#39;copy&#39; attribute is specified - &#39;assign&#39; is assumed&quot;</code></td><td align="left"><code>T@,VidDefault</code></td></tr><tr><td align="left"><code>@property int *intPointer;</code></td><td align="left"><code>T^i,VintPointer</code></td></tr><tr><td align="left"><code>@property void *voidPointerDefault;</code></td><td align="left"><code>T^v,VvoidPointerDefault</code></td></tr><tr><td align="left"><code>@property int intSynthEquals;</code>In the implementation block:<code>@synthesize intSynthEquals=_intSynthEquals;</code></td><td align="left"><code>Ti,V_intSynthEquals</code></td></tr><tr><td align="left"><code>@property(getter=intGetFoo, setter=intSetFoo:) int intSetterGetter;</code></td><td align="left"><code>Ti,GintGetFoo,SintSetFoo:,VintSetterGetter</code></td></tr><tr><td align="left"><code>@property(readonly) int intReadonly;</code></td><td align="left"><code>Ti,R,VintReadonly</code></td></tr><tr><td align="left"><code>@property(getter=isIntReadOnlyGetter, readonly) int intReadonlyGetter;</code></td><td align="left"><code>Ti,R,GisIntReadOnlyGetter</code></td></tr><tr><td align="left"><code>@property(readwrite) int intReadwrite;</code></td><td align="left"><code>Ti,VintReadwrite</code></td></tr><tr><td align="left"><code>@property(assign) int intAssign;</code></td><td align="left"><code>Ti,VintAssign</code></td></tr><tr><td align="left"><code>@property(retain) id idRetain;</code></td><td align="left"><code>T@,&amp;,VidRetain</code></td></tr><tr><td align="left"><code>@property(copy) id idCopy;</code></td><td align="left"><code>T@,C,VidCopy</code></td></tr><tr><td align="left"><code>@property(nonatomic) int intNonatomic;</code></td><td align="left"><code>Ti,VintNonatomic</code></td></tr><tr><td align="left"><code>@property(nonatomic, readonly, copy) id idReadonlyCopyNonatomic;</code></td><td align="left"><code>T@,R,C,VidReadonlyCopyNonatomic</code></td></tr><tr><td align="left"><code>@property(nonatomic, readonly, retain) id idReadonlyRetainNonatomic;</code></td><td align="left"><code>T@,R,&amp;,VidReadonlyRetainNonatomic</code></td></tr></tbody></table><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文是针对<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">苹果Runtime编程指导</a>的简单翻译，如有错误，烦请指正~ 本文中涉及到消息转发只讲到了两种方式——方法决议<code>resolveInstanceMethod:</code>和消息转发 <code>forwardInvocation:</code> ，中间其实还有一步——<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418855-forwardingtargetforselector" target="_blank" rel="noopener">forwardingTargetForSelector:</a>，有兴趣可以看看。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>调试Runtime源码</title>
    <link href="/2020/04/02/%E8%B0%83%E8%AF%95Runtime%E6%BA%90%E7%A0%81/"/>
    <url>/2020/04/02/%E8%B0%83%E8%AF%95Runtime%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Runtime源码调试"><a href="#Runtime源码调试" class="headerlink" title="Runtime源码调试"></a>Runtime源码调试</h2><p>关于runtime讲解的内容网上非常多，有些地方看的一知半解，最好还是把苹果源码拿来跑一跑更利于理解。一番折腾之后，发现runtime源码调试还是非常简单的。</p><h2 id="源码资源"><a href="#源码资源" class="headerlink" title="源码资源"></a>源码资源</h2><p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">苹果官方源码</a></p><p><a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">github开袋即食版本</a></p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p>1.如果你选择编译苹果官方的源码，emmm…祝你好运。（objc4项目中有很多文件是缺失的，需要去<a href="https://opensource.apple.com/" target="_blank" rel="noopener">官网</a>自己下载匹配）</p><p>2.懒人们看过来，为了更加高效迅速的学习runtime源码，我们选择站在大佬的肩膀看他们编译好的版本，从<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">github开袋即食版本</a>下载好源码，这里建议大家直接把git仓库clone下来，方便后面切换版本及自测。</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeDebug01.png" srcset="/img/loading.gif" alt="runtimeDebug01"></p><h3 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h3><p>打开objc项目</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeDebug02.png" srcset="/img/loading.gif" alt="runtimeDebug02"></p><p>1.objc库target以及编译环境macOS，由于创建的是macOS平台下的Library，所以不支持iOS平台编译，iOS目前动态库仅支持Framework的创建。</p><p>2.源码区，这一块的group基本就是runtime的所有源码了，后面我们调试和查看的源码都在这里。</p><p>3.作者帮我们添加了一个debug-objc的target，main.m是这个target的入口，后面我们调试代码都是在main函数里进行。</p><p>4.product文件，编译好的动态库及其他target颜色会变为黑色，执行clean可以清楚build文件夹里动态库以便重新编译。</p><p>5.项目target，对我们有用的是objc和debug-objc。</p><p>6.objc库的2个脚本，设置动态库链接等，不要动。</p><h2 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h2><h3 id="debug-objc调试"><a href="#debug-objc调试" class="headerlink" title="debug-objc调试"></a>debug-objc调试</h3><p>使用源码库自带的debug-objc target调试时注意一下几点：</p><p>1.设置objc与debug-objc的General中的Deployment Target不大于你的mac系统版本（有时不设置会报错，如无错误提示可不管），debug-objc的Signing &amp; Capabilities设置中取消Automatically manage signing ,team设为None即可。</p><p>2.scheme选择objc进行run，编译成功后，Products目录下libobjc.A.dylib颜色正常并可以在文件夹中找到，一般路径为/Users/XXX/Library/Developer/Xcode/DerivedData/XXX/Build/Products/Debug/libobjc.A.dylib ,Command + Shift + .可以显示隐藏文件夹Library。</p><p>3.在debug-objc文件中的main.m文件中，main函数里打上断点，scheme选择debug-objc进行run，运行成功后走到断点处，此时我们在lldb里面输入image list 查看工程使用的库：</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeDebug03.png" srcset="/img/loading.gif" alt="runtimeDebug03"></p><p>如果你看到libobjc.A.dylib库的地址是你项目编译的库地址时，那么恭喜你大功告成！</p><p>这里可能有一部分人得到的路径结果是 /usr/lib/libobjc.A.dylib ，稍安勿躁，继续往下看。</p><h3 id="自建工程调试"><a href="#自建工程调试" class="headerlink" title="自建工程调试"></a>自建工程调试</h3><p>创建自己的测试工程（注意是macOS下的app）完成后，在Build Phases中添加脚本</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeDebug04.png" srcset="/img/loading.gif" alt="runtimeDebug04"></p><pre><code>install_name_tool -change /usr/lib/libobjc.A.dylib /Users/XXX/Library/Developer/Xcode/DerivedData/XXX/Build/Products/Debug/libobjc.A.dylib /Users/XXX/Library/Developer/Xcode/DerivedData/XXX/Build/Products/Debug/MACRuntimeTest2.app/Contents/MacOS/MACRuntimeTest2</code></pre><p>/usr/lib/libobjc.A.dylib是系统自带的runtime库，我们如果需要调试源码，就需要用我们自己编译的runtime库替换掉系统的库，上面这段脚本实际上就是为测试工程替换runtime库地址。</p><p>同样在我们运行项目之后断点，查看image list ，检查runtime库是否替换成功。</p><p>如果运行的时候遇到 Bad executable问题</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeDebug05.png" srcset="/img/loading.gif" alt="runtimeDebug05"></p><p>解决办法：重启Xcode -&gt; clean -&gt; build -&gt; run</p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>对于在上面调试中遇到问题，例如libobjc.A.dylib并没有被替换为我们自己编译的库，或者是编译报错 Symbol not found</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeDebug06.png" srcset="/img/loading.gif" alt="runtimeDebug06"></p><p>这里我们要先弄清楚2个问题</p><p>1.苹果会持续更新runtime源码库，因为mac系统版本升级需要兼容，这个git源码也会跟着官方更新，所以如果你编译最新版本的源码，请先升级你的系统和Xcode，否则你只能编译较低版本，这也是为什么我建议大家clone源码，便于切换版本。</p><p>2.SIP（系统完整性保护）开发的同学应该多多少少接触过，很多三方应用或者平台都需要对系统文件做修改，那么就必须先关掉SIP，我们的runtime源码库因为会替换系统的源码库，所以也必须先把SIP关掉。</p><p>在终端中输入csrutil status查看SIP状态，如果是enabled，那么就需要进入Recovery模式关闭。完成之后继续我们上面的步骤。</p><p>关于debug的问题，在git上也有一个<a href="https://github.com/RetVal/objc-runtime/issues/20" target="_blank" rel="noopener">issue</a>，如果有后续更新，大家也可以看一下。</p><h2 id="源码调试"><a href="#源码调试" class="headerlink" title="源码调试"></a>源码调试</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeDebug07.png" srcset="/img/loading.gif" alt="runtimeDebug07"></p><p>在main函数中，初始化一个NSObject，然后step into进源码（注意按住control和control-shift的操作）</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeDebug08.png" srcset="/img/loading.gif" alt="runtimeDebug08"></p><p>ok，目的完成，现在可以尽情探索啦。</p><h3 id="汇编调试"><a href="#汇编调试" class="headerlink" title="汇编调试"></a>汇编调试</h3><p>有时候对于方法底层调用不够清楚，想要完整的查看调用流程，我们可以借助汇编模式查看代码运行过程</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeDebug09.png" srcset="/img/loading.gif" alt="runtimeDebug09"></p><p>如图，开启汇编调试模式，这样我们所有的断点都会进入汇编代码里。以之前main函数中断点为例</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeDebug10.png" srcset="/img/loading.gif" alt="runtimeDebug10"></p><p>可以很清晰的看到我们的函数入口，以及函数实现中的方法调用，对于指令和相关地址我们可以用expr命令打印。</p><p>至于跳转的操作，我们根据自己的需要使用step over 和step in（按住control进入指令内部，或者按住control-shift进入线程）。</p><p>另外，有没有注意到main函数的汇编代码里有熟悉的autoreleasePoolPush和autorealesePoolPop呢?又是一个知识点呀。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，runtime源码解析的部分已经总结完了，是不是觉得很简单？</p><p>其实当中还有很多可以扩展的地方，包括相对路径相对路径（@rpath,@loader_path, @executable_path）；shell脚本DYLD_INSERT_LIBRARIES，install_name_tool，动态库替换；汇编模式expr调试，符号断点等等。越学习越发现自己的懂的东西是多么的少，继续努力！</p><p>如有错误，烦请指正~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OC与Swift混编</title>
    <link href="/2020/03/18/OC%E4%B8%8ESwift%E6%B7%B7%E7%BC%96/"/>
    <url>/2020/03/18/OC%E4%B8%8ESwift%E6%B7%B7%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h2 id="OC与Swift混编"><a href="#OC与Swift混编" class="headerlink" title="OC与Swift混编"></a>OC与Swift混编</h2><p>总结一下在OC与Swift混编的配置以及在开发中需要注意的一些点.</p><h1 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h1><h2 id="桥接文件"><a href="#桥接文件" class="headerlink" title="桥接文件"></a>桥接文件</h2><p>当我们在Swift项目（OC项目）中首次添加OC文件（Swift文件）时，Xcode会自动弹出桥接文件创建的提示，如图</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/OC-Swift1.png" srcset="/img/loading.gif" alt=""></p><p>这里我们可以选择Xcode自动创建或者手动创建，创建完成后系统会自动生成2个桥接文件，如图</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/OC-Swift2.png" srcset="/img/loading.gif" alt=""></p><p>$(SWIFT_MODULE_NAME)-Bridging-Header.h，这个头文件直接在目录中，如图</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/OC-Swift3.png" srcset="/img/loading.gif" alt=""></p><p>$(SWIFT_MODULE_NAME)-Swift.h在目录中不可见.</p><p>如果我们需要手动创建的也是可以的，只要保证文件名与Build Setting中path一直即可，不过推荐使用系统默认的创建.</p><h2 id="头文件导入"><a href="#头文件导入" class="headerlink" title="头文件导入"></a>头文件导入</h2><p>一般混编项目中常用的头文件有-Bridging-Header.h，-Swift.h，-pch等，在OC与swift混编时，如果Swift需要引用OC的类，那么需要再-Bridging-Header.h中引入OC头文件，如图</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/OC-Swift4.png" srcset="/img/loading.gif" alt=""></p><p>如果OC类需要引用Swift类时，需要在OC类中import $(SWIFT_MODULE_NAME)-Swift.h</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/OC-Swift5.png" srcset="/img/loading.gif" alt=""></p><p>导入后OC类即可使用项目中所有继承于NSObject的Swift类，这里需要注意的时，未继承NSObject的Swift类无法被OC调用.</p><p>这里点进$(SWIFT_MODULE_NAME)-Swift.h看一看，除了顶部一大堆宏定义宏方法外，Xcode还帮我们把所有继承自NSObject的Swift类编译成OC的接口，所以OC才能正常调用Swift类的属性和方法.</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/OC-Swift6.png" srcset="/img/loading.gif" alt=""></p><h1 id="cocoaPod"><a href="#cocoaPod" class="headerlink" title="cocoaPod"></a>cocoaPod</h1><p>先说结论，现在（cocoaPod 1.5之后）集成OC和Swift库非常简单，无需考虑use_framework，static framework等等问题，仅需要把要导入的库名添加到podfile文件中即可，但是，初次导入后pod可能会遇到一些警告.</p><pre><code class="ruby">[!] The `Project [Debug]` target overrides the `SWIFT_INCLUDE_PATHS` build setting defined in `Pods/Target Support Files/Pods-Project/Pods-Project.debug.xcconfig&#39;. This can lead to problems with the CocoaPods installation    - Use the `$(inherited)` flag, or    - Remove the build settings from the target.[!] The `Project [Release]` target overrides the `SWIFT_INCLUDE_PATHS` build setting defined in `Pods/Target Support Files/Pods-Project/Pods-Project.release.xcconfig&#39;. This can lead to problems with the CocoaPods installation    - Use the `$(inherited)` flag, or    - Remove the build settings from the target.</code></pre><p>可以看到，Pods-DadaStaff.debug.xcconfig文件中的SWIFT_INCLUDE_PATHS被项目tage的buildSeetingt覆盖了，如果不解决的话，会导致Swift三方库无法正常编译成module.</p><p>找到target中的Swift Complier - Search Path，在Import Paths项中添加$(inherited)</p><p><img src="http://q7zkcqazl.bkt.clouddn.com/OC-Swift7.png" srcset="/img/loading.gif" alt=""></p><p>重新pod，消除警告后，即可使用Swift三方库.</p><p>在cocoaPod更新到1.5之前，OC与Swift混编比较头疼的一个问题就是pod库的集成，历史原因这里就不赘述了，有兴趣可以参考下面2个链接：</p><p><a href="https://www.jianshu.com/p/3d0ae289dee0" target="_blank" rel="noopener">cocoapods的静态库和动态库</a></p><p><a href="http://blog.cocoapods.org/CocoaPods-1.5.0/" target="_blank" rel="noopener">CocoaPods 1.5.0</a></p><h1 id="语法混编"><a href="#语法混编" class="headerlink" title="语法混编"></a>语法混编</h1><h2 id="OC调用Swift"><a href="#OC调用Swift" class="headerlink" title="OC调用Swift"></a>OC调用Swift</h2><p>简单说下OC调用Swift需要注意的点：</p><p>1.import $(SWIFT_MODULE_NAME)-Swift.h</p><pre><code class="Swift">#import &quot;OCAndSwift-Swift.h&quot;</code></pre><p>2.调用Swift类时，Swift类必须继承自NSObject</p><pre><code class="Swift">class SwiftClass: NSObject { var claseName = &quot;SwiftClass&quot;}</code></pre><p>3.调用Swift类的方法，属性时，Swift类的方法属性都必须加上@objc关键字</p><pre><code class="Swift">@objc var retrainConfirmBlock: (() -&gt; Void)?@objc convenience init()</code></pre><p>4.如果使用KVC，KVO等监听，需要对监听的属性加上dynamic关键字，因为Swift并不是动态派发的语言，dynamic关键字会让编译器进行动态分发而不是静态分发.</p><pre><code class="Swift">@objc dynamic var orderNumber: NSNumber?</code></pre><h2 id="Swift调用OC"><a href="#Swift调用OC" class="headerlink" title="Swift调用OC"></a>Swift调用OC</h2><p>Swift调用OC需要注意的点：</p><p>1.$(SWIFT_MODULE_NAME)-Bridging-Header.h引入OC类头文件.</p><p>2.OC类的相关属性及方法在Swift类中都可以直接调用，只需要注意Swift语法即可.</p><pre><code class="Swift">UIView.animate(withDuration: TimeInterval(time), delay: 0, options: UIView.AnimationOptions.curveLinear, animations: {// animate }) {(finish) in//finish}</code></pre><p>3.OC类的多数基本类型如NSArray，NSDictionay，NSError等对象(Object) 都可以通过 as? 和Swift中的基础类型Array，Dictionary，Error等值类型互换.</p><pre><code class="Swift">let contentAry = info[&quot;content&quot;] as? [String]titleLabel.text = title as? String ?? &quot;&quot;if let failedWith = error as? Error {}</code></pre><p>4.OC宏的使用，Swift使用OC的宏，只能直接使用非常简单的值类型宏，对于复杂的宏方法则需要自己重写一个全局方法替代，全局静态常量可以直接使用.</p><pre><code class="objective-c">#define kExpireTime 60  // √#define sharedAppDelegate ((AppDelegate *)([UIApplication sharedApplication].delegate)) // X</code></pre><h2 id="Swift特性"><a href="#Swift特性" class="headerlink" title="Swift特性"></a>Swift特性</h2><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>1.简单介绍一下Optional-可选类型，Optional实际上是一个枚举类型：</p><pre><code class="swift">public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral {case nonecase some(Wrapped)...}</code></pre><p>表示一个数据可能有值也可能为空即nil，类型可以用Optional<T>或者T?（常用）表示.</p><p>2.如果一个可选类型有值，那么这个值也是被包装起来的，例如optional(“test”)，如果需要取出值就需要解包</p><p>解包方式有 if let 以及！，！表示强解，一般在确定值不为空的时候使用，否则会造成崩溃.</p><pre><code class="swift">if let text = OptionalText {print(text)}let text = OptionalText!</code></pre><p>3.在与OC混编过程中，因为OC没有可选类型的概念，需要注意可选类型带来的问题.例如</p><pre><code class="swift">@objc init(offset: CGFloat? = nil,  text: String? = &quot;&quot;) {super.init(frame: .zero)self.type = typeself.offset = offset}</code></pre><p>这个方法如果想给OC调用则会报错</p><pre><code class="swift">Method cannot be marked @objc because the type of the parameter 1 cannot be represented in Objective-C</code></pre><p>提示第一个参数无法用OC表示，因为在OC中CGFloat是值类型，不能为nil，而对于OC中的对象类型NSString （String自动转换）则可以接受.</p><p>另外，Swift使用OC定义类型时也要注意是否为可空类型</p><pre><code class="objective-c">@property (nonatomic, strong) NSNumber *number1;@property (nonatomic, strong, nullable) NSNumber *number2;</code></pre><p>带nullable关键字的属性可以被Swift转为可选类型，但是不带nullable的属性则默认被！强解，这里需要注意使用OC网络数据等，如果不做判断可以会导致崩溃.</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是Swift中的一大利器，许多swift的标准库都是通过泛型代码构建的，例如数组和字典都是泛型集，在系统库或者一些知名三方库中，随处可见的Element，&lt;T&gt;，Where等等占位符或关键字，都是使用泛型在构建代码，引用一段Swift文档对于泛型的描述.</p><blockquote><p><em>Generic code</em> enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.</p><p>Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code. In fact, you’ve been using generics throughout the <em>Language Guide</em>, even if you didn’t realize it. For example, Swift’s <code>Array</code> and <code>Dictionary</code> types are both generic collections. You can create an array that holds <code>Int</code> values, or an array that holds <code>String</code> values, or indeed an array for any other type that can be created in Swift. Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be.</p></blockquote><p>概括泛型的关键字：自定义，任意类型，灵活，重用，清晰，抽象.篇幅关系，Swift泛型的应用以后再详细总结.</p><p>在Xcode7之后，为了“迎合”Swift，苹果对OC也做了许多提升，其中包括Nullability，轻量级泛型和__kindof等等，nullable上文我们提到过，可以在Swift使用OC属性时自动编译为Optional类型，那么在在泛型的混编上应该注意什么呢？</p><h4 id="1-OC种泛型的使用"><a href="#1-OC种泛型的使用" class="headerlink" title="1.OC种泛型的使用"></a>1.OC种泛型的使用</h4><p>在OC当中对泛型比较常用的方式，例如对数组元素类型的定义</p><pre><code class="objective-c">NSArray&lt;NSString *&gt; *messageArray</code></pre><p>一方面可以限制集合类型，一方面可以直接使用点语法，并且在添加，遍历时会有类型提示.</p><h4 id="2-OC泛型的定义"><a href="#2-OC泛型的定义" class="headerlink" title="2.OC泛型的定义"></a>2.OC泛型的定义</h4><p>OC中2种自定义泛型定义：</p><pre><code class="objective-c"> __covariant:协变, 子类转父类 __contravariant:逆变 父类转子类</code></pre><p>那么什么是协变，逆变呢，我们用一个例子来说明</p><pre><code class="objective-c">@interface Generic&lt;ObjectType&gt; : NSObject@end@interface ViewController ()@property (nonatomic, strong) Generic * generic;@property (nonatomic, strong) Generic&lt;NSString*&gt; * stringGeneric;@property (nonatomic, strong) Generic&lt;NSMutableString*&gt; * mutableGeneric;@end@implementation ViewController- (void)viewDidLoad {    [super viewDidLoad];    self.generic = self.stringGeneric;    self.generic = self.mutableGeneric;    self.stringGeneric = self.generic;    self.stringGeneric = self.mutableGeneric; // Incompatible pointer types assigning to &#39;Generic&lt;NSString*&gt; *&#39; from &#39;Generic&lt;NSMutableString*&gt; *&#39;    self.mutableGeneric = self.generic;    self.mutableGeneric = self.stringGeneric; // Incompatible pointer types assigning to &#39;Generic&lt;NSMutableString*&gt; *&#39; from &#39;Generic&lt;NSString*&gt; *&#39;}@end</code></pre><p>从代码警告我们可以看出：</p><ol><li>不指定泛型类型的对象generic可以和任意泛型类型对象转换.</li><li>指定了泛型类型的对象generic不能和不同泛型类型对象转换(只是警告).</li></ol><p>如果你需要主动控制转换关系则需要添加 __covariant 或 __contravariant，效果如下：</p><pre><code class="objective-c">@interface Generic&lt;__covariant ObjectType&gt; : NSObjectself.stringGeneric = self.mutableGeneric; // 子类转父类self.mutableGeneric = self.stringGeneric; // Incompatible pointer types assigning to &#39;Generic&lt;NSMutableString*&gt; *&#39; from &#39;Generic&lt;NSString*&gt; *&#39;</code></pre><pre><code class="objective-c">@interface Generic&lt;__contravariant ObjectType&gt; : NSObjectself.stringGeneric = self.mutableGeneric; // Incompatible pointer types assigning to &#39;Generic&lt;NSString*&gt; *&#39; from &#39;Generic&lt;NSMutableString*&gt; *&#39;self.mutableGeneric = self.stringGeneric; // 父类转子类</code></pre><h4 id="3-OC泛型在Swift中的使用"><a href="#3-OC泛型在Swift中的使用" class="headerlink" title="3.OC泛型在Swift中的使用"></a>3.OC泛型在Swift中的使用</h4><p>1.OC中定义的泛型，在Swift中使用时，必须指定泛型类型</p><pre><code>let g = Generic&lt;AnyObject&gt;()</code></pre><p>2.使用泛型类型的子类时，如果想要使用父类的方法或属性，建议先使用as转换类型，获取到方法列表或属性列表后，再把as去掉，因为子类无法直接获取到父类的方法属性列表，有点坑.</p><pre><code class="swift">let gChild = GenericChild&lt;AnyObject&gt;()(gChild as GenericChild&lt;AnyObject&gt;).genericFunc()gChild.genericFunc()</code></pre><p>3.swift并不吃OC泛型的协变，逆变这一套，它只有一个基本原则：类型固定.只要你在初始化时说明了对象的泛型类型，那么他不管怎么转换类型，指针赋值，始终只能转换为他自己的类型.</p><pre><code class="swift">let gString = Generic&lt;NSString&gt;()var gMutableString = Generic&lt;NSMutableString&gt;()gMutableString = gString as! Generic&lt;NSMutableString&gt;</code></pre><h4 id="4-Swift泛型在OC中的使用"><a href="#4-Swift泛型在OC中的使用" class="headerlink" title="4.Swift泛型在OC中的使用"></a>4.Swift泛型在OC中的使用</h4><p>不行（可以查看一下$(SWIFT_MODULE_NAME)-Swift.h中是没有将Swift泛型类编译成OC类的哦）.</p><h3 id="closure"><a href="#closure" class="headerlink" title="closure"></a>closure</h3><p>1.OC中的blcok与Swift中closure都是经常使用的代码类型，Swift调用OC block会自动转化为closure类型.</p><pre><code class="objective-c">void (^completionBlock)(NSData *, NSError *) = ^(NSData *data,NSError *error) {/* ... */}</code></pre><pre><code class="swift">let completionBlock: (NSData, NSError) -&gt; Void = {data, errorin /* ... */}</code></pre><p>2.Swift中closure和function是同一种类型，所以可以将Swift的方法名作为block参数传递给OC.</p><pre><code class="swift">let completionBlock: (NSData, NSError) -&gt; Void = {data, error    in /* ... */}func completionBlockFunc(_ data:NSData, _ error:NSError) -&gt; Void {        /* ... */    }</code></pre><p>3.block默认截获变量，如果需要截获引用，则需要加上__block关键字，closure默认截获变量的指针，也就是说closure默认就添加了__block关键字，但是在变量没有改变的情况下，closure会做优化只持有变量的值而不是指针.</p><blockquote><p>As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by or outside a closure.</p></blockquote><p>4.循环引用及Weak-Strong Dance</p><p>OC中未避免循环引用，会对持有对象做weak处理，Swift中修饰对象为弱引用有2种方式.</p><pre><code class="swift">// 对此对象进行弱引用，此对象引用计数不会增加，修饰的对象为可选类型weak var object// 对此对象进行弱引用，此对象引用计数不会增加，修饰的对象不能为nilunowned var objectself.closure = {    [unowned self] in    // self 不能为空，否则会造成崩溃    self.viewDidLoad() } self.closure = {     [weak self] in     // self 是可选类型，此处可以解包self     self?.viewDidLoad()}</code></pre><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>OC中NS_ENUM枚举定义和Swift中的Enum默认是相互转化的，但是秉着简洁清晰的代码原则，Swift把OC中枚举类型名称给yan割了，例如</p><pre><code class="objective-c">typedef NS_ENUM(NSInteger, UITableViewCellStyle) { UITableViewCellStyleDefault, UITableViewCellStyleValue1, UITableViewCellStyleValue2, UITableViewCellStyleSubtitle};</code></pre><p>等价于</p><pre><code class="swift">enum UITableViewCellStyle: Int {    case Default    case Value1    case Value2    case Subtitle}</code></pre><p>Swift用点语法来使用枚举：（许多系统的枚举类也被改了，如果不知道怎么写，可以把OC的系统枚举写上，会有错误提示帮你更正）</p><pre><code class="swift">let cellStyle: UITableViewCellStyle = .Default</code></pre><p>Swift中的枚举比起OC来强大了很多，OC中的枚举只能定义类型，但是Swift中的枚举可以添加方法和属性，类似于Struct，可以实现很多自定义的功能.</p><pre><code class="swift">enum NDDErrCode: Int, CustomStringConvertible {    case success = 0    case fail    case noData    case noMoreData    var description: String {        switch self {        case .success:            return &quot;成功&quot;        case .fail:            return &quot;失败&quot;        case .noData:            return &quot;没有数据&quot;        case .noMoreData:            return &quot;没有更多数据&quot;        }    }}</code></pre><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><p>OC中Protocol更倾向于代理功能，由Protocol协议，代理对象delegate以及委托者<delegate>组成，主要用于事件回调，页面传值等功能；</p><p>Swift中的Protocol更多的是面向协议编程，指抽象出不同类的相同行为（方法），特点（属性）等等，实现模块化解耦.还可以通过extension，实现协议的默认方法（OC不行），也无需生命代理对象等.</p><p>Swift调用OC的Protocol和调用方法一样，OC调用Swift协议时，需要注意创建Protocol时，@objc，optional等关键字和协议类型（any，class，anyObject）等协议遵循限制.</p><h4 id="RAC-and-RxSwift"><a href="#RAC-and-RxSwift" class="headerlink" title="RAC and RxSwift"></a>RAC and RxSwift</h4><p>Swift可以使用RAC（不建议，毕竟有正宫娘娘RxSwift），除了语法外，需要注意RAC大部分类也是OC泛型，需要类型转换以获取父子类方法及属性列表.</p><p>OC无法使用RxSwift.</p><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>OC单例</p><pre><code class="objective-c">+ (instancetype)sharedInstance {    static Singleton *shared = nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        shared = [[Singleton alloc] init];    });    return _shared;}</code></pre><p>Swift单例</p><pre><code class="swift">static let sharedInstance = Singleton()</code></pre><h4 id="json转模型"><a href="#json转模型" class="headerlink" title="json转模型"></a>json转模型</h4><p>OC中常用json转对象工具MJExtension，Swift中常用工具较多，如HandyJson，ObjectMapper等等，另外Swift4引入的Codable协议也是非常方便的.</p><h4 id="OC变参方法"><a href="#OC变参方法" class="headerlink" title="OC变参方法"></a>OC变参方法</h4><p>OC的变参方法无法直接在Swift中被调用，需要对变参方法进行修改，使用va_list对变参进行拼接.</p><p>原方法</p><pre><code class="objective-c">+ (void)stringParams:(NSString *)params,...;</code></pre><p>重写方法</p><pre><code class="objective-c">+ (void) stringParams:(NSString *)params args:(va_list)args {    va_list args_copy;    __va_copy(args_copy,args);    NSMutableString* format = [NSMutableString stringWithString:@&quot;&quot;];    while (va_arg(args, NSString*))    {        [format appendString:@&quot;%@,&quot;];    }    va_end(args);    if(format.length&gt;0)        [format deleteCharactersInRange:NSMakeRange(format.length-1,1)];    NSString* newFormat = [NSString stringWithFormat:@&quot;%@&quot;,format];    NSString * result = [[NSString alloc]initWithFormat:newFormat arguments:args_copy];    va_end(args_copy);    NSLog(@&quot;%@&quot;, result);}</code></pre><p>swift调用</p><pre><code class="swift">let args: [CVarArg] = [&quot;i&#39;m&quot;, &quot; funny&quot;]        withVaList(args) {                (pointer: CVaListPointer) in            return ViewController.stringParams(&quot;%@,%@&quot;, args: pointer)                }</code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上只是在偏业务混编开发过程中遇到的部分问题，在技术，项目性能以及编程思想等方面还有很多问题没总结到，后面遇到了再持续更新吧…</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
