<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Runtime简介 - liebenSchnee</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>liebenSchnee</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期四, 四月 16日 2020, 4:46 下午
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    8.1k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      30 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <h2 id="Runtime简介"><a href="#Runtime简介" class="headerlink" title="Runtime简介"></a>Runtime简介</h2><p>OC语言会尽可能的将代码（库）编译和链接等操作推迟到运行的时候去处理。这意味着OC不仅需要编译器，更需要一个运行时系统来动态的执行编译的代码。运行时系统就好比OC的操作系统，让OC真正运转起来。</p>
<p>这篇文档聚焦于OC中的基类<code>NSObject</code>以及OC语言是如何与运行时系统进行交互的，另外会特别解析类的动态创建加载以及转发消息给其他类的过程。同时也会提供在项目运行过程中获取类相关信息的方法。</p>
<p>阅读这篇文档会让你理解OC运行时的机制并且如何善加利用成为大牛，当然，这并不意味这一定要懂运行时才能开发苹果应用（但是不懂的话肯定是不能装逼了:no_good:）。</p>
<h1 id="平台及版本"><a href="#平台及版本" class="headerlink" title="平台及版本"></a>平台及版本</h1><p>简单了解一下Runtime的历史版本</p>
<table>
<thead>
<tr>
<th></th>
<th>语言版本</th>
<th>硬件及软件版本</th>
<th>异同</th>
</tr>
</thead>
<tbody><tr>
<td>modern（现代版）</td>
<td>OC2.0</td>
<td>iPhone，64bit OS X v10.5~</td>
<td>改变父类属性结构，不需要重新编译其子类</td>
</tr>
<tr>
<td>legacy（遗产版）</td>
<td>OC1.0</td>
<td>32bit OS X</td>
<td>改变父类属性结构，需要重新编译其子类</td>
</tr>
</tbody></table>
<h1 id="runtime的应用"><a href="#runtime的应用" class="headerlink" title="runtime的应用"></a>runtime的应用</h1><p>OC项目主要在三个方面运用到运行时系统：OC代码编写；使用Foundation库中的<code>NSObject</code>基类定义的各类方法；直接调用运行时动态库函数。</p>
<h2 id="OC代码"><a href="#OC代码" class="headerlink" title="OC代码"></a>OC代码</h2><p>大部分时候，运行时扮演着幕后角色，在你编写，编译OC代码时偷偷摸摸在后面搞事情。编写包含OC的类和方法时，编译器会生成对应的数据结构和函数调用，数据结构会从类，分类以及代理里获取类对象，代理对象，函数，实例变量等等信息。获取信息的方法就是通过运行时的蓝波湾机制–消息机制。</p>
<h2 id="NSObject-方法"><a href="#NSObject-方法" class="headerlink" title="NSObject 方法"></a>NSObject 方法</h2><p>Cocoa中大部分对象都是<code>NSObject</code>的子类，它们都继承了<code>NSObject</code>定义的方法（NSProxy是个例外）。一般来说，<code>NSObject</code>定义的方法决定了它的实例和子类的行为，但在部分情况下，<code>NSObject</code>仅仅提供某些行为的模板，而不是提供具体的代码实现。</p>
<p>例如，<code>NSObject</code>定义了一个名为<code>description</code>的实例方法，用来返回一个描述类包含内容的字符串。这个方法主要用来调试使用，GDB的调试命令<code>print-object</code>打印的即是从<code>description</code>这个方法返回的字符串。<code>NSObject</code>在实现<code>description</code>这个方法时并不知道当前类的内容，所以单纯的返回了当前类的名称和地址信息。<code>NSObject</code>的子类可以重写这个方法以返回更多信息，例如<code>NSArray</code> 的<code>description</code>方法返回的是它所包含的元素的信息。</p>
<p>部分<code>NSObject</code>的方法更是直接从运行时系统中获取自身相关的一些信息。例如</p>
<p><code>class</code>方法用来获取对象的类；</p>
<p><code>isKindOfClass:</code>和<code>isMemberOfClass:</code>用来判断对象的继承树；</p>
<p><code>respondsToSelector:</code>用来判断对象能否响应某些特定的消息；</p>
<p><code>conformsToProtocol:</code>用来判断对象是否实现了某个协议中的方法；</p>
<p><code>methodForSelector:</code>提供了某个方法的实现地址；</p>
<p>类似于上述的这些方法，给了对象剖析自身信息的一种能力。</p>
<h2 id="Runtime-函数"><a href="#Runtime-函数" class="headerlink" title="Runtime 函数"></a>Runtime 函数</h2><p>运行时系统是一个共享动态库，位于系统的<code>/usr/lib/objc</code>，在它的头文件中提供了一系列的函数和数据结构作为公开接口。这里面的许多函数允许你用简单的C语言复刻编译器在你编写OC代码时所做的事情。其他的一些函数则促成了<code>NSObject</code>类中函数功能性输出的基础（我也不知道这句话翻译的是什么鬼。。）。这些函数可以让我们开发与运行时交互的更多接口以及增加开发环境的工具。虽然编写OC代码并不太需要运行时函数，但是在某些情况下，运行时对于项目开发帮助很大。<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime" target="_blank" rel="noopener">运行时官方文档</a></p>
<h1 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h1><p>这一段将解析消息表达式是如何转化为<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="noopener">objc_msgSend</a>函数调用的，以及你如何通过名称找到方法。然后我们会讲解怎么利用<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="noopener">objc_msgSend</a>函数，怎么避免动态绑定（如果需要的话）。</p>
<h2 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h2><p>在OC中，消息在运行时之前是不会和函数实现绑定在一起的。编译器会将消息转化为一个表达式：</p>
<pre><code class="objc">[receiver message]</code></pre>
<p>让他去调用消息函数–<code>objc_msgSend</code>，消息函数会将上述消息结构体中的receiver和message中包含的方法名（即我们所熟悉的selector）作为自己的2个主要参数</p>
<pre><code>objc_msgSend(receiver, selector)</code></pre><p>任何传给message消息的参数都会传递给<code>objc_msgSend</code>函数</p>
<pre><code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code></pre><p><code>objc_msgSend</code>函数实现了动态绑定的过程：</p>
<ul>
<li>同一个方法可能被不同的类实现，首先根据receiver的类找到selector对应的方法实现MI（method implementation）。</li>
<li>将reveicer对象（指针或数据）以及传递给<code>objc_msgSend</code>的参数全部传递给找到的方法实现MI并调用。</li>
<li>最后，将MI的返回值作为自己的返回值。</li>
</ul>
<blockquote>
<p>编译器会自动将方法调用转化为消息函数<code>objc_msgSend</code>，不要自己在代码里面直接调用。</p>
</blockquote>
<p>消息机制的关键在于编译器为每个类和对象构建的数据结构。每个类的数据结构包含2个基本要素：</p>
<ul>
<li>指向父类的指针</li>
<li>类的调度表，调度表能够将方法名selector与对应类定义的方法实现地址关联起来，例如<code>setOrigin::</code>这个方法的方法名会和<code>setOrigin::</code>的方法实现（method implementation）地址关联，<code>display</code>方法名会和<code>display</code>方法实现地址关联等等。</li>
</ul>
<p>当一个新对象完成创建，分配完内存空间并且初始化实例变量之后，这个对象实例变量的第一个值–isa指针，指向的则是对象的类，通过isa指针，对象可以获取自己的类，通过自己的类可以获取自己的父类等信息。</p>
<blockquote>
<p>严格来说，isa指针并不是OC语言的一部分，但却是OC对象与运行时交互的必要属性。无论在哪里定义，与运行时交互的对象必须类似于 <code>struct objc_object</code>（定义在objc/objc.h，含有isa指针属性）。然后我们并没有必要自己去创建一个根对象，继承自NSObject或NSProxy类的对象自动拥有isa指针属性。</p>
</blockquote>
<p>类和对象的数据结构如下图</p>
<p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeIntro-1.png" srcset="/img/loading.gif" alt=""></p>
<p>当一个消息发送给一个对象时，消息函数<code>objc_msgSend</code>会根据对象的isa指针找到对象的类，消息函数会在类的调度表中寻找消息的方法名。如果找不到的话，<code>objc_msgSend</code>会根据<code>superclass</code>指针向上找到父类，并在父类的调度表里寻找消息的方法名，若一直失败，则会循环往上查询一直到基类NSObject。一旦定位到了方法名，消息函数<code>objc_msgSend</code>会把对象数据结构及参数传给该方法并对该方法进行调用。</p>
<p>上述过程即是方法实现在运行时中被调用的过程，从面向对象编程的思想来看，这就是方法与消息动态绑定的方式。</p>
<p>为了加速消息机制的过程，运行时会把调用过的方法名和方法实现地址缓存起来。每个类都是独自的缓存，不仅可以缓存自己定义的方法，也可以缓存继承的方法。在消息函数<code>objc_msgSend</code>查找调度表之前，会先检查消息对象的缓存（基于消息可能多次调用的想法），如果在缓存中找到了方法，那么消息机制仅仅比直接的方法调用慢了一点点而已。只要程序运行的时间够长来不断的积累“缓存方法”，几乎所有消息都能在缓存中找到方法。缓存会不断的增长对程序运行过程的消息提供越来越快，越来越便利的调用方式。</p>
<h2 id="使用隐藏参数"><a href="#使用隐藏参数" class="headerlink" title="使用隐藏参数"></a>使用隐藏参数</h2><p>当消息函数<code>objc_msgSend</code>找到方法的实现时，会对方法实现进行调用并传递所有参数。同时，它也会对方法实现传递2个隐藏参数：</p>
<ul>
<li>消息对象</li>
<li>方法选择器selector</li>
</ul>
<p>消息表达式中的这两部分参数会将自身的信息传递给每个他们调用的方法。之所以说他们是隐藏参数是因为在源码中定义方法时并不会申明消息对象和方法名。他们是在源码被编译时插入方法实现中的。</p>
<p>尽管这两个参数没有被明确的声明，但是源码依然可以获取到他们（就像获取消息接收对象的实例变量一样），方法将接收到到的对象为<code>self</code>，将它自己的selector方法选择器称为<code>_cmd</code>。在下面这个示例中，<code>_cmd</code>指的是<code>strange</code>方法的selector方法选择器，<code>self</code>指的是接收到<code>strange</code>消息的对象。</p>
<pre><code class="objective-c">- strange
{
    id  target = getTheReceiver();
    SEL method = getTheMethod();

    if ( target == self || method == _cmd )
        return nil;
    return [target performSelector:method];
}</code></pre>
<p><code>self</code>在这两个参数中属于更重要的一个，实际上，<code>self</code>是方法定义能够使用接收对象实例变量的一种方式。</p>
<h2 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h2><p>唯一能够避免方法动态绑定的方式是获取到方法的地址，然后直接当做函数进行调用。在某些不常见的场景下，比如需要对某个特定方法进行非常多次连续的调用，如果你想避免消息机制每次动态绑定的开销，你可以使用这个方式。</p>
<p>你可以通过<code>NSObject</code>中定义的方法<code>methodForSelector:</code>来获取一个方法的函数实现地址，然后通过这个地址直接调用函数。<code>methodForSelector:</code>这个方法返回的地址需要转换为适当的函数类型，返回值和参数类型都需要包含在转换的函数类型中。</p>
<p>下面的例子展示了<code>setFilled:</code>方法如何通过函数指针地址调用：</p>
<pre><code class="objective-c">void (*setter)(id, SEL, BOOL);
int i;

setter = (void (*)(id, SEL, BOOL))[target
    methodForSelector:@selector(setFilled:)];
for ( i = 0 ; i &lt; 1000 ; i++ )
    setter(targetList[i], @selector(setFilled:), YES);</code></pre>
<p>传递给函数实现的头两个参数分别是接收对象<code>self</code>和方法的selector方法选择器<code>_cmd</code>。这两个参数在方法定义中隐藏，但是在方法作为函数被调用时必须显式的声明。</p>
<p>使用<code>methodForSelector:</code>这个方法来避免消息机制的动态绑定节省了许多动态绑定的时间，但是这些只在特定情况，比如上述例子中，for循环里重复多次消息发送时才显得有用处。</p>
<p>注意到<code>methodForSelector:</code>是由Cocoa运行时提供的方法，并不是Objective-C的特性哦。</p>
<h1 id="动态方法决议"><a href="#动态方法决议" class="headerlink" title="动态方法决议"></a>动态方法决议</h1><p>这一段将告诉你如何动态的添加一个方法的实现。</p>
<h2 id="动态方法决议-1"><a href="#动态方法决议-1" class="headerlink" title="动态方法决议"></a>动态方法决议</h2><p>在某些时候，你可能想要自己动态的添加一个方法的实现。举个栗子，OC的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_blank" rel="noopener">属性声明</a>特性中包含了<code>@dynamic</code>关键字</p>
<pre><code class="objective-c">@dynamic propertyName;</code></pre>
<p>这个关键字告诉编译器，这个属性关联的方法将会被动态提供。</p>
<p>你可以通过实现 <code>resolveInstanceMethod:</code>和 <code>resolveClassMethod:</code>方法分别为给定的实例方法和类方法提供方法实现。</p>
<p>OC中的方法其实等同于C的函数，只是至少包含两个参数——<code>self</code>和<code>_cmd</code>。你可以通过 <code>class_addMethod</code>函数给类添加一个函数作为它的方法。所以，给出以下函数：</p>
<pre><code class="objective-c">void dynamicMethodIMP(id self, SEL _cmd) {
    // implementation ....
}</code></pre>
<p>你可以通过<code>resolveInstanceMethod:</code>这个方法，动态的将上面的函数添加给一个类作为方法（方法名为<code>resolveThisMethodDynamically</code>），如下：</p>
<pre><code class="objective-c">@implementation MyClass
+ (BOOL)resolveInstanceMethod:(SEL)aSEL
{
    if (aSEL == @selector(resolveThisMethodDynamically)) {
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);
          return YES;
    }
    return [super resolveInstanceMethod:aSEL];
}
@end</code></pre>
<p>消息转发（下一段会讲到）和方法动态决议在很大程度上是在正交的。一个类在方法转发介入之前可以对方法进行方法决议，如果 <code>respondsToSelector:</code>或者 <code>instancesRespondToSelector:</code>成功调用返回YES，方法动态决议就有机会先给方法添加动态实现。如果你实现了 <code>resolveInstanceMethod:</code>了但是需要某些特定的方法通过消息转发机制进行转发，你可以在 <code>resolveInstanceMethod:</code>中对这些方法返回NO。</p>
<h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><p>OC的程序可以在运行时加载链接新的类和分类等，这些新的类和分类会被合并到程序中就像最开始被加载的类和分类一样。</p>
<p>动态加载可以用来做很多事情，例如系统设置app中的许多模块都是动态加载的。</p>
<p>在Cocoa的环境中，动态加载通常用来自定义应用，另外可以用来编写各种模块让你的程序在运行时进行加载——就像Xib加载自定义调色板或是OSX系统偏好设置加载自定义偏好模块等。可加载的模块可以扩展你的应用的能力，它们可以以你允许的方式提供帮助，但是你自己是无法预料和定义这个过程的。你提供框架，其他人提供代码。</p>
<p>尽管在Mach-O文件中已经有运行时的函数（定义在<code>objc/objc-load.h</code>中的<code>objc_loadModules</code>）用来对OC的模块进行动态加载，Cocoa中的<code>NSBundle</code>类中提供了一系列重要且方便的接口——面向对象且整合了相关服务的接口，用来进行动态加载。你可以在Foundation Framework中查看<code>NSBundle</code>类的相关信息及使用，也可以在 <a href="https://github.com/aidansteele/osx-abi-macho-file-format-reference" target="_blank" rel="noopener"><em>OS X ABI Mach-O File Format Reference</em></a>中查看Mach-O文件中的信息。</p>
<h1 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h1><p>给一个对象发送一个它并未实现的消息时会造成错误，然而，在抛出错误之前，运行时系统会给接收消息的对象第二次机会去处理这个消息。</p>
<h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>如果你向一个对象发送一个未实现的消息A，在抛出错误之前，运行时会向接收消息的对象发送一个 <code>forwardInvocation:</code> 消息，这个消息只有一个 <code>NSInvocation</code> 对象的参数，这个参数包括了原消息A和原消息A所带有的参数。</p>
<p>你可以实现 <code>forwardInvocation:</code> 方法给消息A一个默认的实现，或者用其他方式避免这种调用错误。通过 <code>forwardInvocation:</code>的字面意思（转发调用）我们可以知道，这个函数通常用来转发消息给其他对象。</p>
<p>为了了解消息转发的适用范围和意义，想象下面这样一个场景：假设，首先，你设计一个对象A能够响应一个名为 <code>negotiate</code>的方法，这时你希望这个方法的响应包含了另外一个对象B的响应。通过你在对象A中实现 <code>negotiate</code>方法的地方，将 <code>negotiate</code>消息转递给另外一个对象B即可完成。</p>
<p>更进一步，假设你希望对象A对于 <code>negotiate</code> 这个方法的响应和另外一个对象B对于 <code>negotiate</code> 这个方法的响应完全一致的话，其中一种实现方式是让对象A继承与对象B，然而当对象A和对象B处于不同的继承树之间时，这个方法就不那么好用了。</p>
<p>当然，即是你的对象A无法继承对象B的 <code>negotiate</code>方法，你仍然可以通过实现你自己版本的<code>negotiate</code>方法，在方法实现中，将<code>negotiate</code>消息传递给对象B的实例以此来“借用”对象B对于<code>negotiate</code>方法的响应。</p>
<pre><code class="objective-c">- (id)negotiate
{
    if ( [someOtherObjectB respondsTo:@selector(negotiate)] )
        return [someOtherObjectB negotiate];
    return self;
}</code></pre>
<p>这种方式的消息转发看起来有点麻烦，特别是当你需要通过你的对象转发一系列消息给其他对象的时候。你需要实现一个方法来覆盖你想要从其他对象那“借用”的每个方法。此外，在你编写代码时，如果你不知道所有你需要转发的消息时，也不可能处理这些情况。这些需要转发的消息集可能依赖于运行时，并且可能随着未来新的方法和类的加入而改变。</p>
<p>给我们第二次机会的 <code>forwardInvocation:</code> 方法提供了一个不那么特别的方式来解决这个问题，并且与上面的方式相比更加动态。这个方法的机制是这样的：当一个对象由于没有对应的方法与接收到的消息匹配而无法响应这个消息时，运行时系统通过发送 <code>forwardInvocation:</code>消息给这个对象来通知它。每个继承自NSObject的对象都继承了 <code>forwardInvocation:</code>这个方法。然而NSObject对于这个方法的默认实现是直接调用 <code>doesNotRecognizeSelector:</code>抛出异常。通过重写<code>forwardInvocation:</code>这个方法你可以利用它将接收到的消息转发给其他对象。</p>
<p>转发消息，<code>forwardInvocation:</code>需要做一下两步：</p>
<ul>
<li>确定这个消息应该转发给谁</li>
<li>将消息的原始参数带上，将消息转发给对应的对象</li>
</ul>
<p>消息时通过 <code>invokeWithTarget:</code> 这个方法转发出去的</p>
<pre><code class="objective-c">- (void)forwardInvocation:(NSInvocation *)anInvocation
{
    if ([someOtherObject respondsToSelector:
            [anInvocation selector]])
        [anInvocation invokeWithTarget:someOtherObject];
    else
        [super forwardInvocation:anInvocation];
}</code></pre>
<p>被转发消息的返回值将会被返回给消息的原始发送者，包括id，结构体，单精度，双精度浮点数等等。</p>
<p> <code>forwardInvocation:</code> 方法可以被看作是不识别消息的配送中心，它可以将这些不被识别的消息转发给不同的接受者。或者，你可以将它看做是转运站，它可以将所有消息最终传递到同一个目的地。它可以将一个消息转化为另一个消息，或者干脆“吃掉”一些消息，让它们没有响应也不会报错。 <code>forwardInvocation:</code> 也可以将好几个消息合并起来只返回一个响应。 <code>forwardInvocation:</code> 的作用完全取决于它自身的实现，但是，它在转发链中提供的链接不同对象的机会，使多样灵活的程序设计成为可能。</p>
<blockquote>
<p><code>forwardInvocation:</code> 只有在对象（消息接受者）没有实现某个消息对应的方法时，才会接手对消息的转发。举个栗子，如果你想要对象A把 <code>negotiate</code> 转发给其他对象，那么对象A就不能实现自己的 <code>negotiate</code> 方法，否则，<code>forwardInvocation:</code> 永远不会对 <code>negotiate</code> 进行转发。</p>
</blockquote>
<p>如果你想要了解更多消息转发以及调用的信息，可以查阅Foundation framework文档中的 <code>NSInvocation</code> 类。</p>
<h2 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h2><p>消息转发机制有点继承的意味，它可以用来给OC添加一些多继承的效果。如下图所示，一个对象通过消息转发来响应一个消息，有点像是“借用”或者是“继承”了实现了这个消息的另一个类。</p>
<p><img src="http://q7zkcqazl.bkt.clouddn.com/runtimeIntro-2.png" srcset="/img/loading.gif" alt=""></p>
<p>如上图示，一个<code>Warrior</code>（战士）类的对象转发了 <code>negotiate</code> （协商）消息给了一个<code>Diplomat</code>（外交官）类的对象，那么这个“战士”对象将会像“外交官”对象一样响应“协商”方法。（实际上“协商”消息一直是“外交官”对象在处理）。</p>
<p>一个对象通过转发消息因而“继承”了两个继承树分支——它自己的继承树分支以及响应转发消息的对象的继承树分支的方法。在上述的例子中，看起来好像是<code>Warrior</code>（战士）类对象同时继承了<code>Warrior</code>（战士）类和<code>Diplomat</code>（外交官）类。</p>
<p>消息转发提供了你通常希望从多继承获得的大部分特性，然而这两者有个很重要的区别：多继承会融合很多不同的特性在同一个对象上，它倾向于更大，更多面的对象；而消息转发是将不同的职责分配给不同的对象，它将问题分解为更小的对象去处理，对于消息发送者，消息转发对于不同对象的链接联合是透明可见的。</p>
<h2 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h2><p>消息转发不但模仿多继承，它还可以让更轻量级的对象来表示或“顶替”更复杂的对象。这些轻量级的对象会代替其他对象，并且将收到的消息转发给它们。</p>
<p>我们在 <em><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="noopener">The Objective-C Programming Language</a></em> 中“Remote Messaging”里面讨论的“Proxy（代理）”正是一个代理对象，一个proxy负责管理将消息发送给远程接受者过程中的各种细节，确保在连接过程中参数的复制和接收等等。但是也仅此而已，它并不会复制远程对象的功能性，只是简单的提供一个本地地址，让它可以在其他应用中接收消息。</p>
<p>也有其他类型的代理对象，例如，当你有一个需要处理非常多数据——创建复杂图像或者读取磁盘数据等的对象，设置此对象可能非常耗时，这时你打算使用懒加载的方式——当需要使用到它或者系统资源空闲的时候来做。与此同时，你需要一个默认的代理对象来代替这个复杂的对象，以便让程序中其他的对象能够正常工作。</p>
<p>在这种情况下，你一开始可以只创建一个非常简单的代理对象，这个对象可以做一些简单的操作例如返回对于数据的查询，但主要还是帮复杂对象“占个位”，当时机来临，将消息转发给复杂对象。当代理对象的 <code>forwardInvocation:</code> 方法首次接收到需要传递给其他对象的消息时，代理对象会确保消息接收对象存在或者在其不存在时创建一个。所有需要传递给复杂对象的消息都经由代理对象发出，所以，在程序的其他部分看来，代理对象和复杂对象其实并没有区别。</p>
<h2 id="转发与继承"><a href="#转发与继承" class="headerlink" title="转发与继承"></a>转发与继承</h2><p>虽然上面说了很多转发模仿继承之类的，但是<code>NSObject</code>类从来不会将两者混为一谈，像 <code>respondsToSelector:</code> 和<code>isKindOfClass:</code>方法只在继承树中做判断，从来不会在转发链中去判断。例如，当上述<code>Warrior</code>（战士）类调用 <code>respondsToSelector:</code> 方法来判断是否响应 <code>negotiate</code> 消息时</p>
<pre><code class="objective-c">if ( [aWarrior respondsToSelector:@selector(negotiate)] )
    ...</code></pre>
<p>返回值是<code>NO</code>，即是它在某种意义上，通过将消息转发给<code>Diplomat</code>（外交官）类，可以正确的响应 <code>negotiate</code> 消息。</p>
<p>在很多情况下，<code>NO</code>是正确的答案，但事实可能并非如此。如果你利用消息转发创建一个代理对象或者扩展一个类的能力，转发机制应该和继承一样清晰可见。如果你希望你的对象通过将消息转发给其他对象，就像真正继承了这些对象的行为，那么你需要重写<code>respondsToSelector:</code>和<code>isKindOfClass:</code>等这些方法，将消息转发机制考虑在内</p>
<pre><code class="objective-c">- (BOOL)respondsToSelector:(SEL)aSelector
{
    if ( [super respondsToSelector:aSelector] )
        return YES;
    else {
        /* Here, test whether the aSelector message can     *
         * be forwarded to another object and whether that  *
         * object can respond to it. Return YES if it can.  */
    }
    return NO;
}</code></pre>
<p>除了 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>外， <code>instancesRespondToSelector:</code> 方法也应该考虑转发机制，如果使用到协议，那么 <code>conformsToProtocol:</code> 方法同样要考虑转发机制。同样的，如果一个对象可以转发它收到的任何消息，它应该实现 <code>methodSignatureForSelector:</code>这个方法，这个方法可以返回最终响应转发消息的方法的详细信息，即<code>NSMethodSignature</code>方法签名，举个栗子，如果一个对象可以转发消息给他的代理对象，那么你应该实现 <code>methodSignatureForSelector:</code>，如下：</p>
<pre><code class="objective-c">- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector
{
    NSMethodSignature* signature = [super methodSignatureForSelector:selector];
    if (!signature) {
       signature = [surrogate methodSignatureForSelector:selector];
    }
    return signature;
}</code></pre>
<p>你可以考虑将转发消息的一些判断或算法抽离出来放在私有代码里，然后让上述<code>respondsToSelector:</code>，<code>isKindOfClass:</code>，<code>instancesRespondToSelector:</code> ，包括<code>forwardInvocation:</code>等方法去调用它。</p>
<blockquote>
<p>消息转发是一种高级技巧，只适用于在走投无路的时候使用，它并不是继承的代替方案。如果你一定要使用消息转发，确保你充分了解，转发消息的类和消息接收类的行为。</p>
</blockquote>
<p>这一段提到的各种方法收录在 Foundation framework文档中的<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject" target="_blank" rel="noopener">NSObject</a> 类里。 <code>invokeWithTarget:</code>方法的相关内容在Foundation framework文档中<a href="https://developer.apple.com/documentation/foundation/nsinvocation" target="_blank" rel="noopener">NSInvocation</a>里。</p>
<h1 id="类型编码"><a href="#类型编码" class="headerlink" title="类型编码"></a>类型编码</h1><p>为了辅助运行时系统，编译器会将每个方法的参数和返回值编码成字符串形式，并把这个字符串和方法选择器selector关联起来。这种编码形式在其他场景下也适用，可以使用公用的编译器指令 <code>@encode()</code> 来应用。当给定一种类型， <code>@encode()</code> 指令会返回这种类型的字符串编码。这种类型可以是<code>int</code>，指针，结构体，<code>union</code>或者是任何类的名称。事实上，编码后的字符串也可以作为C语言 <code>sizeof()</code> 操作的参数。</p>
<pre><code class="objective-c">char *buf1 = @encode(int **);
char *buf2 = @encode(struct key);
char *buf3 = @encode(Rectangle);</code></pre>
<p>下表中列出了各种类型编码。需要注意的是，当对一个对象进行<code>archive</code>或<code>distribution</code>操作编码时，下列类型编码会和你自己的代码重复。然而在你编写编码器时，下列的一些类型编码你无法使用，还有一些编码在你编写不是由<code>@encode()</code>方法生成的编码器时可以使用。（具体参照Foundation Framework中<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSCoder/Description.html#//apple_ref/occ/cl/NSCoder" target="_blank" rel="noopener">NSCoder</a>类，获取更多关于<code>archive</code>或<code>distribution</code>相关编码信息）</p>
<table>
<thead>
<tr>
<th align="left">Code</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>c</code></td>
<td align="left">A <code>char</code></td>
</tr>
<tr>
<td align="left"><code>i</code></td>
<td align="left">An <code>int</code></td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td align="left">A <code>short</code></td>
</tr>
<tr>
<td align="left"><code>l</code></td>
<td align="left">A <code>long``l</code> is treated as a 32-bit quantity on 64-bit programs.</td>
</tr>
<tr>
<td align="left"><code>q</code></td>
<td align="left">A <code>long long</code></td>
</tr>
<tr>
<td align="left"><code>C</code></td>
<td align="left">An <code>unsigned char</code></td>
</tr>
<tr>
<td align="left"><code>I</code></td>
<td align="left">An <code>unsigned int</code></td>
</tr>
<tr>
<td align="left"><code>S</code></td>
<td align="left">An <code>unsigned short</code></td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left">An <code>unsigned long</code></td>
</tr>
<tr>
<td align="left"><code>Q</code></td>
<td align="left">An <code>unsigned long long</code></td>
</tr>
<tr>
<td align="left"><code>f</code></td>
<td align="left">A <code>float</code></td>
</tr>
<tr>
<td align="left"><code>d</code></td>
<td align="left">A <code>double</code></td>
</tr>
<tr>
<td align="left"><code>B</code></td>
<td align="left">A C++ <code>bool</code> or a C99 <code>_Bool</code></td>
</tr>
<tr>
<td align="left"><code>v</code></td>
<td align="left">A <code>void</code></td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td align="left">A character string (<code>char *</code>)</td>
</tr>
<tr>
<td align="left"><code>@</code></td>
<td align="left">An object (whether statically typed or typed <code>id</code>)</td>
</tr>
<tr>
<td align="left"><code>#</code></td>
<td align="left">A class object (<code>Class</code>)</td>
</tr>
<tr>
<td align="left"><code>:</code></td>
<td align="left">A method selector (<code>SEL</code>)</td>
</tr>
<tr>
<td align="left">[<em>array type</em>]</td>
<td align="left">An array</td>
</tr>
<tr>
<td align="left">{<em>name=type…</em>}</td>
<td align="left">A structure</td>
</tr>
<tr>
<td align="left">(<em>name</em>=<em>type…</em>)</td>
<td align="left">A union</td>
</tr>
<tr>
<td align="left"><code>b</code>num</td>
<td align="left">A bit field of <em>num</em> bits</td>
</tr>
<tr>
<td align="left"><code>^</code>type</td>
<td align="left">A pointer to <em>type</em></td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">An unknown type (among other things, this code is used for function pointers)</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：Objective-C 并不支持 <code>long double</code> 类型，<code>@encode(long double)</code>方法返回值为<code>d</code>，和<code>double</code>编码相同</p>
</blockquote>
<p>数组的类型编码是由中括号包起来的，数组的元素数量紧跟着左括号后面，例如，一个包含12个指向浮点数的指针数组会被编码成</p>
<pre><code class="c">[12^f]</code></pre>
<p>结构体的编码会被大括号包裹，而联合的编码则被小括号包裹，结构体的标签会列在括号里第一位，紧着这后面是一个等于号，然后就是结构体内部的各项属性的编码，例如</p>
<pre><code class="c">typedef struct example {
    id   anObject;
    char *aString;
    int  anInt;
} Example;</code></pre>
<p>这个结构体会被编码为</p>
<pre><code class="c">{example=@*i}</code></pre>
<p>无论是将结构体的名称（Example）或是结构体的标签（example）传递给 <code>@encode()</code>方法编码后都是上述结果。结构体指针的编码同样会带着结构体编码的内容：</p>
<pre><code class="c">^{example=@*i}</code></pre>
<p>然而，对于结构体指针的指针编码，则会移除结构体的编码结构：</p>
<pre><code class="c">^^{example}</code></pre>
<p>对象编码类似于结构体编码，例如，将 <code>NSObject</code> 类名传给 <code>@encode()</code>进行编码，结果是</p>
<pre><code class="c">{NSObject=#}</code></pre>
<p> <code>NSObject</code> 对象只申明了一个实例变量——<code>isa</code>，代表类的类型。</p>
<p>注意到到下表中额外的类型编码，尽管不是通过 <code>@encode()</code> 方法返回的，但是运行时系统会使用下列编码来标识在协议中申明的方法的类型。</p>
<table>
<thead>
<tr>
<th align="left">Code</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>r</code></td>
<td align="left"><code>const</code></td>
</tr>
<tr>
<td align="left"><code>n</code></td>
<td align="left"><code>in</code></td>
</tr>
<tr>
<td align="left"><code>N</code></td>
<td align="left"><code>inout</code></td>
</tr>
<tr>
<td align="left"><code>o</code></td>
<td align="left"><code>out</code></td>
</tr>
<tr>
<td align="left"><code>O</code></td>
<td align="left"><code>bycopy</code></td>
</tr>
<tr>
<td align="left"><code>R</code></td>
<td align="left"><code>byref</code></td>
</tr>
<tr>
<td align="left"><code>V</code></td>
<td align="left"><code>oneway</code></td>
</tr>
</tbody></table>
<h1 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h1><p>当编译器处理属性声明（在 *<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="noopener">The Objective-C Programming Language</a>*中查看 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_blank" rel="noopener">Declared Properties</a>）时，编译器会生成与声明属性所属类或分类或代理协议等相关的描述性元数据。你可以通过支持从类或者协议中查询属性名称的方法来获取这些元信息，获取属性<code>@encode</code>编码方式的类型字符，还可以以C字符串数组的形式获取属性的属性列表。声明属性的列表对每个类和协议都适用。</p>
<h2 id="属性类型及函数"><a href="#属性类型及函数" class="headerlink" title="属性类型及函数"></a>属性类型及函数</h2><p> <code>Property</code> 属性结构体描述了属性描述符的不透明句柄。</p>
<pre><code class="objective-c">typedef struct objc_property *Property;</code></pre>
<p>你可以使用 <code>class_copyPropertyList</code> 和 <code>protocol_copyPropertyList</code> 来分别获取类，分类，协议等相关的属性列表信息</p>
<pre><code class="objective-c">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)
objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)</code></pre>
<p>举个栗子，如下定义类：</p>
<pre><code class="objective-c">@interface Lender : NSObject {
    float alone;
}
@property float alone;
@end</code></pre>
<p>你可以这样获取它的属性列表：</p>
<pre><code class="objective-c">id LenderClass = objc_getClass(&quot;Lender&quot;);
unsigned int outCount;
objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</code></pre>
<p>你可以使用 <code>property_getName</code> 方法来获取属性的名称：</p>
<pre><code class="objective-c">const char *property_getName(objc_property_t property)</code></pre>
<p>你可以通过 <code>class_getProperty</code> 和 <code>protocol_getProperty</code> 方法，通过给定的名称分别从类和协议中获取指定的属性：</p>
<pre><code class="objective-c">objc_property_t class_getProperty(Class cls, const char *name)
objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</code></pre>
<p>你可以通过 <code>property_getAttributes</code> 方法来获取属性的名称和 <code>@encode</code> 类型编码字符。查看 <a href="#类型编码">类型编码</a>获取更多关于类型编码字符的信息，查看<a href="#属性类型字符">属性类型字符</a> 和 <a href="#属性内容描述示例">属性内容描述示例</a>获取更多关于属性编码字符的信息。</p>
<pre><code class="objective-c">const char *property_getAttributes(objc_property_t property)</code></pre>
<p>将上述方法结合起来，我们可以打印和类相关的所有属性信息：</p>
<pre><code class="objective-c">id LenderClass = objc_getClass(&quot;Lender&quot;);
unsigned int outCount, i;
objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);
for (i = 0; i &lt; outCount; i++) {
    objc_property_t property = properties[i];
    fprintf(stdout, &quot;%s %s\n&quot;, property_getName(property), property_getAttributes(property));
}
</code></pre>
<h2 id="属性类型字符"><a href="#属性类型字符" class="headerlink" title="属性类型字符"></a>属性类型字符</h2><p>你可以通过 <code>property_getAttributes</code> 方法来获取属性的名称和 <code>@encode</code> 类型编码字符和属性的其他内容。</p>
<p>属性的类型编码以T开头，后面紧跟属性的 <code>@encode</code> 类型编码字符和一个逗号，中间部分是属性的修饰符类型的编码字符如下表，以逗号分隔，最后部分是以V开头，后面紧跟属性名称。</p>
<table>
<thead>
<tr>
<th align="left">Code</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>R</code></td>
<td align="left">The property is read-only (<code>readonly</code>).</td>
</tr>
<tr>
<td align="left"><code>C</code></td>
<td align="left">The property is a copy of the value last assigned (<code>copy</code>).</td>
</tr>
<tr>
<td align="left"><code>&amp;</code></td>
<td align="left">The property is a reference to the value last assigned (<code>retain</code>).</td>
</tr>
<tr>
<td align="left"><code>N</code></td>
<td align="left">The property is non-atomic (<code>nonatomic</code>).</td>
</tr>
<tr>
<td align="left"><code>G&lt;name&gt;</code></td>
<td align="left">The property defines a custom getter selector name. The name follows the <code>G</code> (for example, <code>GcustomGetter,</code>).</td>
</tr>
<tr>
<td align="left"><code>S&lt;name&gt;</code></td>
<td align="left">The property defines a custom setter selector name. The name follows the <code>S</code> (for example, <code>ScustomSetter:,</code>).</td>
</tr>
<tr>
<td align="left"><code>D</code></td>
<td align="left">The property is dynamic (<code>@dynamic</code>).</td>
</tr>
<tr>
<td align="left"><code>W</code></td>
<td align="left">The property is a weak reference (<code>__weak</code>).</td>
</tr>
<tr>
<td align="left"><code>P</code></td>
<td align="left">The property is eligible for garbage collection.</td>
</tr>
<tr>
<td align="left"><code>t&lt;encoding&gt;</code></td>
<td align="left">Specifies the type using old-style encoding.</td>
</tr>
</tbody></table>
<p>示例请看<a href="##属性内容描述示例">属性内容描述示例</a>。</p>
<h2 id="属性内容描述示例"><a href="#属性内容描述示例" class="headerlink" title="属性内容描述示例"></a>属性内容描述示例</h2><p>给出以下定义：</p>
<pre><code class="objective-c">enum FooManChu { FOO, MAN, CHU };
struct YorkshireTeaStruct { int pot; char lady; };
typedef struct YorkshireTeaStruct YorkshireTeaStructType;
union MoneyUnion { float alone; double down; };</code></pre>
<p>下表中展示了示例声明属性以及 <code>property_getAttributes</code>:方法的返回值：</p>
<table>
<thead>
<tr>
<th align="left">Property declaration</th>
<th align="left">Property description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@property char charDefault;</code></td>
<td align="left"><code>Tc,VcharDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property double doubleDefault;</code></td>
<td align="left"><code>Td,VdoubleDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property enum FooManChu enumDefault;</code></td>
<td align="left"><code>Ti,VenumDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property float floatDefault;</code></td>
<td align="left"><code>Tf,VfloatDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property int intDefault;</code></td>
<td align="left"><code>Ti,VintDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property long longDefault;</code></td>
<td align="left"><code>Tl,VlongDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property short shortDefault;</code></td>
<td align="left"><code>Ts,VshortDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property signed signedDefault;</code></td>
<td align="left"><code>Ti,VsignedDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property struct YorkshireTeaStruct structDefault;</code></td>
<td align="left"><code>T{YorkshireTeaStruct=&quot;pot&quot;i&quot;lady&quot;c},VstructDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property YorkshireTeaStructType typedefDefault;</code></td>
<td align="left"><code>T{YorkshireTeaStruct=&quot;pot&quot;i&quot;lady&quot;c},VtypedefDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property union MoneyUnion unionDefault;</code></td>
<td align="left"><code>T(MoneyUnion=&quot;alone&quot;f&quot;down&quot;d),VunionDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property unsigned unsignedDefault;</code></td>
<td align="left"><code>TI,VunsignedDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property int (*functionPointerDefault)(char *);</code></td>
<td align="left"><code>T^?,VfunctionPointerDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property id idDefault;</code>Note: the compiler warns: <code>&quot;no &#39;assign&#39;, &#39;retain&#39;, or &#39;copy&#39; attribute is specified - &#39;assign&#39; is assumed&quot;</code></td>
<td align="left"><code>T@,VidDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property int *intPointer;</code></td>
<td align="left"><code>T^i,VintPointer</code></td>
</tr>
<tr>
<td align="left"><code>@property void *voidPointerDefault;</code></td>
<td align="left"><code>T^v,VvoidPointerDefault</code></td>
</tr>
<tr>
<td align="left"><code>@property int intSynthEquals;</code>In the implementation block:<code>@synthesize intSynthEquals=_intSynthEquals;</code></td>
<td align="left"><code>Ti,V_intSynthEquals</code></td>
</tr>
<tr>
<td align="left"><code>@property(getter=intGetFoo, setter=intSetFoo:) int intSetterGetter;</code></td>
<td align="left"><code>Ti,GintGetFoo,SintSetFoo:,VintSetterGetter</code></td>
</tr>
<tr>
<td align="left"><code>@property(readonly) int intReadonly;</code></td>
<td align="left"><code>Ti,R,VintReadonly</code></td>
</tr>
<tr>
<td align="left"><code>@property(getter=isIntReadOnlyGetter, readonly) int intReadonlyGetter;</code></td>
<td align="left"><code>Ti,R,GisIntReadOnlyGetter</code></td>
</tr>
<tr>
<td align="left"><code>@property(readwrite) int intReadwrite;</code></td>
<td align="left"><code>Ti,VintReadwrite</code></td>
</tr>
<tr>
<td align="left"><code>@property(assign) int intAssign;</code></td>
<td align="left"><code>Ti,VintAssign</code></td>
</tr>
<tr>
<td align="left"><code>@property(retain) id idRetain;</code></td>
<td align="left"><code>T@,&amp;,VidRetain</code></td>
</tr>
<tr>
<td align="left"><code>@property(copy) id idCopy;</code></td>
<td align="left"><code>T@,C,VidCopy</code></td>
</tr>
<tr>
<td align="left"><code>@property(nonatomic) int intNonatomic;</code></td>
<td align="left"><code>Ti,VintNonatomic</code></td>
</tr>
<tr>
<td align="left"><code>@property(nonatomic, readonly, copy) id idReadonlyCopyNonatomic;</code></td>
<td align="left"><code>T@,R,C,VidReadonlyCopyNonatomic</code></td>
</tr>
<tr>
<td align="left"><code>@property(nonatomic, readonly, retain) id idReadonlyRetainNonatomic;</code></td>
<td align="left"><code>T@,R,&amp;,VidReadonlyRetainNonatomic</code></td>
</tr>
</tbody></table>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文是针对<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">苹果Runtime编程指导</a>的简单翻译，如有错误，烦请指正~ 本文中涉及到消息转发只讲到了两种方式——方法决议<code>resolveInstanceMethod:</code>和消息转发 <code>forwardInvocation:</code> ，中间其实还有一步——<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418855-forwardingtargetforselector" target="_blank" rel="noopener">forwardingTargetForSelector:</a>，有兴趣可以看看。</p>

            </div>
            <hr>
            <div>
              <p>
                
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var post = $('#post');
      var toc = $('#toc');
      var tocLimMax = post.offset().top + post.height() - navHeight;

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = $('#board-ctn').css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>










<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Runtime简介&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
